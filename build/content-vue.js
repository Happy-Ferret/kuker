(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

/* eslint-disable no-undef, vars-on-top */

var vueDevtools = "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nfunction encode (data, replacer, list, seen) {\n  var stored, key, value, i, l\n  var seenIndex = seen.get(data)\n  if (seenIndex != null) {\n    return seenIndex\n  }\n  var index = list.length\n  if (isPlainObject(data)) {\n    stored = {}\n    seen.set(data, index)\n    list.push(stored)\n    var keys = Object.keys(data)\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i]\n      value = data[key]\n      if (replacer) {\n        value = replacer.call(data, key, value)\n      }\n      stored[key] = encode(value, replacer, list, seen)\n    }\n  } else if (Array.isArray(data)) {\n    stored = []\n    seen.set(data, index)\n    list.push(stored)\n    for (i = 0, l = data.length; i < l; i++) {\n      value = data[i]\n      if (replacer) {\n       value = replacer.call(data, i, value)\n      }\n      stored[i] = encode(value, replacer, list, seen)\n    }\n  } else {\n    index = list.length\n    list.push(data)\n  }\n  return index\n}\n\nfunction decode (list, reviver) {\n  var i = list.length\n  var j, k, data, key, value\n  while (i--) {\n    var data = list[i]\n    if (isPlainObject(data)) {\n      var keys = Object.keys(data)\n      for (j = 0, k = keys.length; j < k; j++) {\n        key = keys[j]\n        value = list[data[key]]\n        if (reviver) value = reviver.call(data, key, value)\n        data[key] = value\n      }\n    } else if (Array.isArray(data)) {\n      for (j = 0, k = data.length; j < k; j++) {\n        value = list[data[j]]\n        if (reviver) value = reviver.call(data, j, value)\n        data[j] = value\n      }\n    }\n  }\n}\n\nfunction isPlainObject (obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]'\n}\n\nexports.stringify = function stringify (data, replacer, space) {\n  try {\n    return arguments.length === 1\n      ? JSON.stringify(data)\n      : JSON.stringify(data, replacer, space)\n  } catch (e) {\n    return exports.stringifyStrict(data, replacer, space)\n  }\n}\n\nexports.parse = function parse (data, reviver) {\n  var hasCircular = /^\\s/.test(data)\n  if (!hasCircular) {\n    return arguments.length === 1\n      ? JSON.parse(data)\n      : JSON.parse(data, reviver)\n  } else {\n    var list = JSON.parse(data)\n    decode(list, reviver)\n    return list[0]\n  }\n}\n\nexports.stringifyStrict = function (data, replacer, space) {\n  var list = []\n  encode(data, replacer, list, new Map())\n  return space\n    ? ' ' + JSON.stringify(list, null, space)\n    : ' ' + JSON.stringify(list)\n}\n\n},{}],2:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n}).call(this,require('_process'))\n},{\"_process\":3}],3:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],4:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initEventsBackend = initEventsBackend;\n\nvar _util = require('../util');\n\nvar _index = require('./index');\n\nvar internalRE = /^(?:pre-)?hook:/;\n\nfunction initEventsBackend(Vue, bridge) {\n  var recording = true;\n\n  bridge.on('events:toggle-recording', function (enabled) {\n    recording = enabled;\n  });\n\n  function logEvent(vm, type, eventName, payload) {\n    // The string check is important for compat with 1.x where the first\n    // argument may be an object instead of a string.\n    // this also ensures the event is only logged for direct $emit (source)\n    // instead of by $dispatch/$broadcast\n    if (typeof eventName === 'string' && !internalRE.test(eventName)) {\n      bridge.send('event:triggered', (0, _util.stringify)({\n        eventName: eventName,\n        type: type,\n        payload: payload,\n        instanceId: vm._uid,\n        instanceName: (0, _index.getInstanceName)(vm._self || vm),\n        timestamp: Date.now()\n      }));\n    }\n  }\n\n  function wrap(method) {\n    var original = Vue.prototype[method];\n    if (original) {\n      Vue.prototype[method] = function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var res = original.apply(this, args);\n        if (recording) {\n          logEvent(this, method, args[0], args.slice(1));\n        }\n        return res;\n      };\n    }\n  }\n\n  wrap('$emit');\n  wrap('$broadcast');\n  wrap('$dispatch');\n}\n\n},{\"../util\":9,\"./index\":7}],5:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.highlight = highlight;\nexports.unHighlight = unHighlight;\nexports.getInstanceRect = getInstanceRect;\n\nvar _util = require('../util');\n\nvar overlay = document.createElement('div');\noverlay.style.backgroundColor = 'rgba(104, 182, 255, 0.35)';\noverlay.style.position = 'fixed';\noverlay.style.zIndex = '99999999999999';\noverlay.style.pointerEvents = 'none';\n\n/**\n * Highlight an instance.\n *\n * @param {Vue} instance\n */\n\nfunction highlight(instance) {\n  if (!instance) return;\n  var rect = getInstanceRect(instance);\n  if (rect) {\n    showOverlay(rect);\n  }\n}\n\n/**\n * Remove highlight overlay.\n */\n\nfunction unHighlight() {\n  if (overlay.parentNode) {\n    document.body.removeChild(overlay);\n  }\n}\n\n/**\n * Get the client rect for an instance.\n *\n * @param {Vue} instance\n * @return {Object}\n */\n\nfunction getInstanceRect(instance) {\n  if (!(0, _util.inDoc)(instance.$el)) {\n    return;\n  }\n  if (instance._isFragment) {\n    return getFragmentRect(instance);\n  } else if (instance.$el.nodeType === 1) {\n    return instance.$el.getBoundingClientRect();\n  }\n}\n\n/**\n * Highlight a fragment instance.\n * Loop over its node range and determine its bounding box.\n *\n * @param {Vue} instance\n * @return {Object}\n */\n\nfunction getFragmentRect(_ref) {\n  var _fragmentStart = _ref._fragmentStart,\n      _fragmentEnd = _ref._fragmentEnd;\n\n  var top = void 0,\n      bottom = void 0,\n      left = void 0,\n      right = void 0;\n  util().mapNodeRange(_fragmentStart, _fragmentEnd, function (node) {\n    var rect = void 0;\n    if (node.nodeType === 1 || node.getBoundingClientRect) {\n      rect = node.getBoundingClientRect();\n    } else if (node.nodeType === 3 && node.data.trim()) {\n      rect = getTextRect(node);\n    }\n    if (rect) {\n      if (!top || rect.top < top) {\n        top = rect.top;\n      }\n      if (!bottom || rect.bottom > bottom) {\n        bottom = rect.bottom;\n      }\n      if (!left || rect.left < left) {\n        left = rect.left;\n      }\n      if (!right || rect.right > right) {\n        right = rect.right;\n      }\n    }\n  });\n  return {\n    top: top,\n    left: left,\n    width: right - left,\n    height: bottom - top\n  };\n}\n\n/**\n * Get the bounding rect for a text node using a Range.\n *\n * @param {Text} node\n * @return {Rect}\n */\n\nvar range = document.createRange();\nfunction getTextRect(node) {\n  range.selectNode(node);\n  return range.getBoundingClientRect();\n}\n\n/**\n * Display the overlay with given rect.\n *\n * @param {Rect}\n */\n\nfunction showOverlay(_ref2) {\n  var _ref2$width = _ref2.width,\n      width = _ref2$width === undefined ? 0 : _ref2$width,\n      _ref2$height = _ref2.height,\n      height = _ref2$height === undefined ? 0 : _ref2$height,\n      _ref2$top = _ref2.top,\n      top = _ref2$top === undefined ? 0 : _ref2$top,\n      _ref2$left = _ref2.left,\n      left = _ref2$left === undefined ? 0 : _ref2$left;\n\n  overlay.style.width = ~~width + 'px';\n  overlay.style.height = ~~height + 'px';\n  overlay.style.top = ~~top + 'px';\n  overlay.style.left = ~~left + 'px';\n  document.body.appendChild(overlay);\n}\n\n/**\n * Get Vue's util\n */\n\nfunction util() {\n  return window.__VUE_DEVTOOLS_GLOBAL_HOOK__.Vue.util;\n}\n\n},{\"../util\":9}],6:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.installHook = installHook;\n// this script is injected into every page.\n\n/**\n * Install the hook on window, which is an event emitter.\n * Note because Chrome content scripts cannot directly modify the window object,\n * we are evaling this function by inserting a script tag. That's why we have\n * to inline the whole event emitter implementation here.\n *\n * @param {Window} window\n */\n\nfunction installHook(window) {\n  var listeners = {};\n\n  var hook = {\n    Vue: null,\n\n    on: function on(event, fn) {\n      event = '$' + event;(listeners[event] || (listeners[event] = [])).push(fn);\n    },\n    once: function once(event, fn) {\n      event = '$' + event;\n      function on() {\n        this.off(event, on);\n        fn.apply(this, arguments);\n      }\n      ;(listeners[event] || (listeners[event] = [])).push(on);\n    },\n    off: function off(event, fn) {\n      event = '$' + event;\n      if (!arguments.length) {\n        listeners = {};\n      } else {\n        var cbs = listeners[event];\n        if (cbs) {\n          if (!fn) {\n            listeners[event] = null;\n          } else {\n            for (var i = 0, l = cbs.length; i < l; i++) {\n              var cb = cbs[i];\n              if (cb === fn || cb.fn === fn) {\n                cbs.splice(i, 1);\n                break;\n              }\n            }\n          }\n        }\n      }\n    },\n    emit: function emit(event) {\n      event = '$' + event;\n      var cbs = listeners[event];\n      if (cbs) {\n        var args = [].slice.call(arguments, 1);\n        cbs = cbs.slice();\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i].apply(this, args);\n        }\n      }\n    }\n  };\n\n  hook.once('init', function (Vue) {\n    hook.Vue = Vue;\n  });\n\n  hook.once('vuex:init', function (store) {\n    hook.store = store;\n  });\n\n  Object.defineProperty(window, '__VUE_DEVTOOLS_GLOBAL_HOOK__', {\n    get: function get() {\n      return hook;\n    }\n  });\n}\n\n},{}],7:[function(require,module,exports){\n(function (process){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initBackend = initBackend;\nexports.getInstanceName = getInstanceName;\n\nvar _highlighter = require('./highlighter');\n\nvar _vuex = require('./vuex');\n\nvar _events = require('./events');\n\nvar _util = require('../util');\n\nvar _path2 = require('path');\n\nvar _path3 = _interopRequireDefault(_path2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Use a custom basename functions instead of the shimed version\n// because it doesn't work on Windows\nfunction basename(filename, ext) {\n  return _path3.default.basename(filename.replace(/^[a-zA-Z]:/, '').replace(/\\\\/g, '/'), ext);\n}\n\n// hook should have been injected before this executes.\n// This is the backend that is injected into the page that a Vue app lives in\n// when the Vue Devtools panel is activated.\n\nvar hook = window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\nvar rootInstances = [];\nvar propModes = ['default', 'sync', 'once'];\n\nvar instanceMap = window.__VUE_DEVTOOLS_INSTANCE_MAP__ = new Map();\nvar consoleBoundInstances = Array(5);\nvar currentInspectedId = void 0;\nvar bridge = void 0;\nvar filter = '';\nvar captureCount = 0;\nvar isLegacy = false;\nvar rootUID = 0;\n\nfunction initBackend(_bridge) {\n  bridge = _bridge;\n  if (hook.Vue) {\n    isLegacy = hook.Vue.version && hook.Vue.version.split('.')[0] === '1';\n    connect();\n  } else {\n    hook.once('init', connect);\n  }\n}\n\nfunction connect() {\n  hook.currentTab = 'components';\n  bridge.on('switch-tab', function (tab) {\n    hook.currentTab = tab;\n    if (tab === 'components') {\n      flush();\n    }\n  });\n\n  // the backend may get injected to the same page multiple times\n  // if the user closes and reopens the devtools.\n  // make sure there's only one flush listener.\n  hook.off('flush');\n  hook.on('flush', function () {\n    if (hook.currentTab === 'components') {\n      flush();\n    }\n  });\n\n  bridge.on('select-instance', function (id) {\n    currentInspectedId = id;\n    var instance = instanceMap.get(id);\n    if (instance) {\n      scrollIntoView(instance);\n      (0, _highlighter.highlight)(instance);\n    }\n    bindToConsole(instance);\n    flush();\n    bridge.send('instance-details', (0, _util.stringify)(getInstanceDetails(id)));\n  });\n\n  bridge.on('filter-instances', function (_filter) {\n    filter = _filter.toLowerCase();\n    flush();\n  });\n\n  bridge.on('refresh', scan);\n  bridge.on('enter-instance', function (id) {\n    return (0, _highlighter.highlight)(instanceMap.get(id));\n  });\n  bridge.on('leave-instance', _highlighter.unHighlight);\n\n  // vuex\n  if (hook.store) {\n    (0, _vuex.initVuexBackend)(hook, bridge);\n  } else {\n    hook.once('vuex:init', function (store) {\n      (0, _vuex.initVuexBackend)(hook, bridge);\n    });\n  }\n\n  // events\n  (0, _events.initEventsBackend)(hook.Vue, bridge);\n\n  bridge.log('backend ready.');\n  bridge.send('ready', hook.Vue.version);\n  console.log('%c vue-devtools %c Detected Vue v' + hook.Vue.version + ' %c', 'background:#35495e ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff', 'background:#41b883 ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff', 'background:transparent');\n  scan();\n}\n\n/**\n * Scan the page for root level Vue instances.\n */\n\nfunction scan() {\n  rootInstances.length = 0;\n  var inFragment = false;\n  var currentFragment = null;\n  walk(document, function (node) {\n    if (inFragment) {\n      if (node === currentFragment._fragmentEnd) {\n        inFragment = false;\n        currentFragment = null;\n      }\n      return true;\n    }\n    var instance = node.__vue__;\n    if (instance) {\n      if (instance._isFragment) {\n        inFragment = true;\n        currentFragment = instance;\n      }\n\n      // respect Vue.config.devtools option\n      var baseVue = instance.constructor;\n      while (baseVue.super) {\n        baseVue = baseVue.super;\n      }\n      if (baseVue.config && baseVue.config.devtools) {\n        // give a unique id to root instance so we can\n        // 'namespace' its children\n        if (typeof instance.__VUE_DEVTOOLS_ROOT_UID__ === 'undefined') {\n          instance.__VUE_DEVTOOLS_ROOT_UID__ = ++rootUID;\n        }\n        rootInstances.push(instance);\n      }\n\n      return true;\n    }\n  });\n  flush();\n}\n\n/**\n * DOM walk helper\n *\n * @param {NodeList} nodes\n * @param {Function} fn\n */\n\nfunction walk(node, fn) {\n  if (node.childNodes) {\n    for (var i = 0, l = node.childNodes.length; i < l; i++) {\n      var child = node.childNodes[i];\n      var stop = fn(child);\n      if (!stop) {\n        walk(child, fn);\n      }\n    }\n  }\n\n  // also walk shadow DOM\n  if (node.shadowRoot) {\n    walk(node.shadowRoot, fn);\n  }\n}\n\n/**\n * Called on every Vue.js batcher flush cycle.\n * Capture current component tree structure and the state\n * of the current inspected instance (if present) and\n * send it to the devtools.\n */\n\nfunction flush() {\n  var start = void 0;\n  if (process.env.NODE_ENV !== 'production') {\n    captureCount = 0;\n    start = window.performance.now();\n  }\n  var payload = (0, _util.stringify)({\n    inspectedInstance: getInstanceDetails(currentInspectedId),\n    instances: findQualifiedChildrenFromList(rootInstances)\n  });\n  if (process.env.NODE_ENV !== 'production') {\n    console.log('[flush] serialized ' + captureCount + ' instances, took ' + (window.performance.now() - start) + 'ms.');\n  }\n  bridge.send('flush', payload);\n}\n\n/**\n * Iterate through an array of instances and flatten it into\n * an array of qualified instances. This is a depth-first\n * traversal - e.g. if an instance is not matched, we will\n * recursively go deeper until a qualified child is found.\n *\n * @param {Array} instances\n * @return {Array}\n */\n\nfunction findQualifiedChildrenFromList(instances) {\n  instances = instances.filter(function (child) {\n    return !child._isBeingDestroyed;\n  });\n  return !filter ? instances.map(capture) : Array.prototype.concat.apply([], instances.map(findQualifiedChildren));\n}\n\n/**\n * Find qualified children from a single instance.\n * If the instance itself is qualified, just return itself.\n * This is ok because [].concat works in both cases.\n *\n * @param {Vue} instance\n * @return {Vue|Array}\n */\n\nfunction findQualifiedChildren(instance) {\n  return isQualified(instance) ? capture(instance) : findQualifiedChildrenFromList(instance.$children);\n}\n\n/**\n * Check if an instance is qualified.\n *\n * @param {Vue} instance\n * @return {Boolean}\n */\n\nfunction isQualified(instance) {\n  var name = getInstanceName(instance).toLowerCase();\n  return name.indexOf(filter) > -1;\n}\n\n/**\n * Capture the meta information of an instance. (recursive)\n *\n * @param {Vue} instance\n * @return {Object}\n */\n\nfunction capture(instance, _, list) {\n  if (process.env.NODE_ENV !== 'production') {\n    captureCount++;\n  }\n  // instance._uid is not reliable in devtools as there\n  // may be 2 roots with same _uid which causes unexpected\n  // behaviour\n  instance.__VUE_DEVTOOLS_UID__ = getUniqueId(instance);\n  mark(instance);\n  var ret = {\n    id: instance.__VUE_DEVTOOLS_UID__,\n    name: getInstanceName(instance),\n    inactive: !!instance._inactive,\n    isFragment: !!instance._isFragment,\n    children: instance.$children.filter(function (child) {\n      return !child._isBeingDestroyed;\n    }).map(capture)\n    // record screen position to ensure correct ordering\n  };if ((!list || list.length > 1) && !instance._inactive) {\n    var rect = (0, _highlighter.getInstanceRect)(instance);\n    ret.top = rect ? rect.top : Infinity;\n  } else {\n    ret.top = Infinity;\n  }\n  // check if instance is available in console\n  var consoleId = consoleBoundInstances.indexOf(instance.__VUE_DEVTOOLS_UID__);\n  ret.consoleId = consoleId > -1 ? '$vm' + consoleId : null;\n  // check router view\n  var isRouterView2 = instance.$vnode && instance.$vnode.data.routerView;\n  if (instance._routerView || isRouterView2) {\n    ret.isRouterView = true;\n    if (!instance._inactive && instance.$route) {\n      var matched = instance.$route.matched;\n      var depth = isRouterView2 ? instance.$vnode.data.routerViewDepth : instance._routerView.depth;\n      ret.matchedRouteSegment = matched && matched[depth] && (isRouterView2 ? matched[depth].path : matched[depth].handler.path);\n    }\n  }\n  return ret;\n}\n\n/**\n * Mark an instance as captured and store it in the instance map.\n *\n * @param {Vue} instance\n */\n\nfunction mark(instance) {\n  if (!instanceMap.has(instance.__VUE_DEVTOOLS_UID__)) {\n    instanceMap.set(instance.__VUE_DEVTOOLS_UID__, instance);\n    instance.$on('hook:beforeDestroy', function () {\n      instanceMap.delete(instance.__VUE_DEVTOOLS_UID__);\n    });\n  }\n}\n\n/**\n * Get the detailed information of an inspected instance.\n *\n * @param {Number} id\n */\n\nfunction getInstanceDetails(id) {\n  var instance = instanceMap.get(id);\n  if (!instance) {\n    return {};\n  } else {\n    return {\n      id: id,\n      name: getInstanceName(instance),\n      state: processProps(instance).concat(processState(instance), processComputed(instance), processRouteContext(instance), processVuexGetters(instance), processFirebaseBindings(instance), processObservables(instance))\n    };\n  }\n}\n\n/**\n * Get the appropriate display name for an instance.\n *\n * @param {Vue} instance\n * @return {String}\n */\n\nfunction getInstanceName(instance) {\n  var name = instance.$options.name || instance.$options._componentTag;\n  if (name) {\n    return (0, _util.classify)(name);\n  }\n  var file = instance.$options.__file; // injected by vue-loader\n  if (file) {\n    return (0, _util.classify)(basename(file, '.vue'));\n  }\n  return instance.$root === instance ? 'Root' : 'Anonymous Component';\n}\n\n/**\n * Process the props of an instance.\n * Make sure return a plain object because window.postMessage()\n * will throw an Error if the passed object contains Functions.\n *\n * @param {Vue} instance\n * @return {Array}\n */\n\nfunction processProps(instance) {\n  var props = void 0;\n  if (isLegacy && (props = instance._props)) {\n    // 1.x\n    return Object.keys(props).map(function (key) {\n      var prop = props[key];\n      var options = prop.options;\n      return {\n        type: 'props',\n        key: prop.path,\n        value: instance[prop.path],\n        meta: {\n          type: options.type ? getPropType(options.type) : 'any',\n          required: !!options.required,\n          mode: propModes[prop.mode]\n        }\n      };\n    });\n  } else if (props = instance.$options.props) {\n    // 2.0\n    var propsData = [];\n    for (var key in props) {\n      var prop = props[key];\n      key = (0, _util.camelize)(key);\n      propsData.push({\n        type: 'props',\n        key: key,\n        value: instance[key],\n        meta: {\n          type: prop.type ? getPropType(prop.type) : 'any',\n          required: !!prop.required\n        }\n      });\n    }\n    return propsData;\n  } else {\n    return [];\n  }\n}\n\n/**\n * Convert prop type constructor to string.\n *\n * @param {Function} fn\n */\n\nvar fnTypeRE = /^(?:function|class) (\\w+)/;\nfunction getPropType(type) {\n  var match = type.toString().match(fnTypeRE);\n  return typeof type === 'function' ? match && match[1] || 'any' : 'any';\n}\n\n/**\n * Process state, filtering out props and \"clean\" the result\n * with a JSON dance. This removes functions which can cause\n * errors during structured clone used by window.postMessage.\n *\n * @param {Vue} instance\n * @return {Array}\n */\n\nfunction processState(instance) {\n  var props = isLegacy ? instance._props : instance.$options.props;\n  var getters = instance.$options.vuex && instance.$options.vuex.getters;\n  return Object.keys(instance._data).filter(function (key) {\n    return !(props && key in props) && !(getters && key in getters);\n  }).map(function (key) {\n    return {\n      key: key,\n      value: instance._data[key]\n    };\n  });\n}\n\n/**\n * Process the computed properties of an instance.\n *\n * @param {Vue} instance\n * @return {Array}\n */\n\nfunction processComputed(instance) {\n  var computed = [];\n  var defs = instance.$options.computed || {};\n  // use for...in here because if 'computed' is not defined\n  // on component, computed properties will be placed in prototype\n  // and Object.keys does not include\n  // properties from object's prototype\n  for (var key in defs) {\n    var def = defs[key];\n    var type = typeof def === 'function' && def.vuex ? 'vuex bindings' : 'computed';\n    // use try ... catch here because some computed properties may\n    // throw error during its evaluation\n    var computedProp = null;\n    try {\n      computedProp = {\n        type: type,\n        key: key,\n        value: instance[key]\n      };\n    } catch (e) {\n      computedProp = {\n        type: type,\n        key: key,\n        value: '(error during evaluation)'\n      };\n    }\n\n    computed.push(computedProp);\n  }\n\n  return computed;\n}\n\n/**\n * Process possible vue-router $route context\n *\n * @param {Vue} instance\n * @return {Array}\n */\n\nfunction processRouteContext(instance) {\n  var route = instance.$route;\n  if (route) {\n    var _path = route.path,\n        query = route.query,\n        params = route.params;\n\n    var value = { path: _path, query: query, params: params };\n    if (route.fullPath) value.fullPath = route.fullPath;\n    if (route.hash) value.hash = route.hash;\n    if (route.name) value.name = route.name;\n    if (route.meta) value.meta = route.meta;\n    return [{\n      key: '$route',\n      value: value\n    }];\n  } else {\n    return [];\n  }\n}\n\n/**\n * Process Vuex getters.\n *\n * @param {Vue} instance\n * @return {Array}\n */\n\nfunction processVuexGetters(instance) {\n  var getters = instance.$options.vuex && instance.$options.vuex.getters;\n  if (getters) {\n    return Object.keys(getters).map(function (key) {\n      return {\n        type: 'vuex getters',\n        key: key,\n        value: instance[key]\n      };\n    });\n  } else {\n    return [];\n  }\n}\n\n/**\n * Process Firebase bindings.\n *\n * @param {Vue} instance\n * @return {Array}\n */\n\nfunction processFirebaseBindings(instance) {\n  var refs = instance.$firebaseRefs;\n  if (refs) {\n    return Object.keys(refs).map(function (key) {\n      return {\n        type: 'firebase bindings',\n        key: key,\n        value: instance[key]\n      };\n    });\n  } else {\n    return [];\n  }\n}\n\n/**\n * Process vue-rx observable bindings.\n *\n * @param {Vue} instance\n * @return {Array}\n */\n\nfunction processObservables(instance) {\n  var obs = instance.$observables;\n  if (obs) {\n    return Object.keys(obs).map(function (key) {\n      return {\n        type: 'observables',\n        key: key,\n        value: instance[key]\n      };\n    });\n  } else {\n    return [];\n  }\n}\n\n/**\n * Sroll a node into view.\n *\n * @param {Vue} instance\n */\n\nfunction scrollIntoView(instance) {\n  var rect = (0, _highlighter.getInstanceRect)(instance);\n  if (rect) {\n    window.scrollBy(0, rect.top);\n  }\n}\n\n/**\n * Binds given instance in console as $vm0.\n * For compatibility reasons it also binds it as $vm.\n *\n * @param {Vue} instance\n */\n\nfunction bindToConsole(instance) {\n  var id = instance.__VUE_DEVTOOLS_UID__;\n  var index = consoleBoundInstances.indexOf(id);\n  if (index > -1) {\n    consoleBoundInstances.splice(index, 1);\n  } else {\n    consoleBoundInstances.pop();\n  }\n  consoleBoundInstances.unshift(id);\n  for (var i = 0; i < 5; i++) {\n    window['$vm' + i] = instanceMap.get(consoleBoundInstances[i]);\n  }\n  window.$vm = instance;\n}\n\n/**\n * Returns a devtools unique id for instance.\n * @param {Vue} instance\n */\nfunction getUniqueId(instance) {\n  var rootVueId = instance.$root.__VUE_DEVTOOLS_ROOT_UID__;\n  return rootVueId + ':' + instance._uid;\n}\n\n}).call(this,require('_process'))\n},{\"../util\":9,\"./events\":4,\"./highlighter\":5,\"./vuex\":8,\"_process\":3,\"path\":2}],8:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initVuexBackend = initVuexBackend;\n\nvar _util = require('src/util');\n\nfunction initVuexBackend(hook, bridge) {\n  var store = hook.store;\n  var recording = true;\n\n  var getSnapshot = function getSnapshot() {\n    return (0, _util.stringify)({\n      state: store.state,\n      getters: store.getters\n    });\n  };\n\n  bridge.send('vuex:init', getSnapshot());\n\n  // deal with multiple backend injections\n  hook.off('vuex:mutation');\n\n  // application -> devtool\n  hook.on('vuex:mutation', function (mutation) {\n    if (!recording) return;\n    bridge.send('vuex:mutation', {\n      mutation: {\n        type: mutation.type,\n        payload: (0, _util.stringify)(mutation.payload)\n      },\n      timestamp: Date.now(),\n      snapshot: getSnapshot()\n    });\n  });\n\n  // devtool -> application\n  bridge.on('vuex:travel-to-state', function (state) {\n    hook.emit('vuex:travel-to-state', state);\n  });\n\n  bridge.on('vuex:import-state', function (state) {\n    hook.emit('vuex:travel-to-state', state);\n    bridge.send('vuex:init', getSnapshot());\n  });\n\n  bridge.on('vuex:toggle-recording', function (enabled) {\n    recording = enabled;\n  });\n}\n\n},{\"src/util\":9}],9:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NAN = exports.INFINITY = exports.UNDEFINED = exports.camelize = exports.classify = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.inDoc = inDoc;\nexports.stringify = stringify;\nexports.parse = parse;\nexports.isPlainObject = isPlainObject;\nexports.searchDeepInObject = searchDeepInObject;\nexports.sortByKey = sortByKey;\n\nvar _circularJsonEs = require('circular-json-es6');\n\nvar _circularJsonEs2 = _interopRequireDefault(_circularJsonEs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction cached(fn) {\n  var cache = Object.create(null);\n  return function cachedFn(str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\n\nvar classifyRE = /(?:^|[-_/])(\\w)/g;\nvar classify = exports.classify = cached(function (str) {\n  return str.replace(classifyRE, toUpper);\n});\n\nvar camelizeRE = /-(\\w)/g;\nvar camelize = exports.camelize = cached(function (str) {\n  return str.replace(camelizeRE, toUpper);\n});\n\nfunction toUpper(_, c) {\n  return c ? c.toUpperCase() : '';\n}\n\nfunction inDoc(node) {\n  if (!node) return false;\n  var doc = node.ownerDocument.documentElement;\n  var parent = node.parentNode;\n  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));\n}\n\n/**\n * Stringify/parse data using CircularJSON.\n */\n\nvar UNDEFINED = exports.UNDEFINED = '__vue_devtool_undefined__';\nvar INFINITY = exports.INFINITY = '__vue_devtool_infinity__';\nvar NAN = exports.NAN = '__vue_devtool_nan__';\n\nfunction stringify(data) {\n  return _circularJsonEs2.default.stringify(data, replacer);\n}\n\nfunction replacer(key, val) {\n  if (val === undefined) {\n    return UNDEFINED;\n  } else if (val === Infinity) {\n    return INFINITY;\n  } else if (Number.isNaN(val)) {\n    return NAN;\n  } else if (val instanceof RegExp) {\n    // special handling of native type\n    return '[native RegExp ' + val.toString() + ']';\n  } else {\n    return sanitize(val);\n  }\n}\n\nfunction parse(data, revive) {\n  return revive ? _circularJsonEs2.default.parse(data, reviver) : _circularJsonEs2.default.parse(data);\n}\n\nfunction reviver(key, val) {\n  if (val === UNDEFINED) {\n    return undefined;\n  } else if (val === INFINITY) {\n    return Infinity;\n  } else if (val === NAN) {\n    return NaN;\n  } else {\n    return val;\n  }\n}\n\n/**\n * Sanitize data to be posted to the other side.\n * Since the message posted is sent with structured clone,\n * we need to filter out any types that might cause an error.\n *\n * @param {*} data\n * @return {*}\n */\n\nfunction sanitize(data) {\n  if (!isPrimitive(data) && !Array.isArray(data) && !isPlainObject(data)) {\n    // handle types that will probably cause issues in\n    // the structured clone\n    return Object.prototype.toString.call(data);\n  } else {\n    return data;\n  }\n}\n\nfunction isPlainObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n\nfunction isPrimitive(data) {\n  if (data == null) {\n    return true;\n  }\n  var type = typeof data === 'undefined' ? 'undefined' : _typeof(data);\n  return type === 'string' || type === 'number' || type === 'boolean';\n}\n\nfunction searchDeepInObject(obj, searchTerm) {\n  var match = false;\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = obj[key];\n    if (compare(key, searchTerm) || compare(value, searchTerm)) {\n      match = true;\n      break;\n    }\n    if (isPlainObject(value)) {\n      match = searchDeepInObject(value, searchTerm);\n      if (match) {\n        break;\n      }\n    }\n  }\n  return match;\n}\n\nfunction compare(mixedValue, stringValue) {\n  if (Array.isArray(mixedValue) && searchInArray(mixedValue, stringValue.toLowerCase())) {\n    return true;\n  }\n  if (('' + mixedValue).toLowerCase().indexOf(stringValue.toLowerCase()) !== -1) {\n    return true;\n  }\n  return false;\n}\n\nfunction searchInArray(arr, searchTerm) {\n  var found = false;\n  for (var i = 0; i < arr.length; i++) {\n    if (('' + arr[i]).toLowerCase().indexOf(searchTerm) !== -1) {\n      found = true;\n      break;\n    }\n  }\n  return found;\n}\n\nfunction sortByKey(state) {\n  return state && state.slice().sort(function (a, b) {\n    if (a.key < b.key) return -1;\n    if (a.key > b.key) return 1;\n    return 0;\n  });\n}\n\n},{\"circular-json-es6\":1}],10:[function(require,module,exports){\n'use strict';\n\nvar _hook = require('src/backend/hook');\n\nvar MAX_MESSAGES_TO_CACHE = 50;\nvar HOOK_KEY = '__VUE_DEVTOOLS_GLOBAL_HOOK__';\nvar KUKER_HOOK_KEY = '__KUKER_VUE_HOOK__';\nvar detectAttempts = 5;\n\nvar detect = function detect(callback) {\n  detectAttempts -= 1;\n\n  if (window[HOOK_KEY] && !!window[HOOK_KEY].Vue) {\n    callback(null, window[HOOK_KEY]);\n  } else {\n    if (detectAttempts === 0) {\n      callback('Can not detect Vue on the page!');\n    }\n    setTimeout(function () {\n      return detect(callback);\n    }, 1000);\n  }\n};\n\n(0, _hook.installHook)(window);\ndetect(function () {\n  var listeners = [];\n  var bridgeListeners = {};\n\n  var _require = require('src/backend/index'),\n      initBackend = _require.initBackend;\n\n  var messages = [];\n\n  window[KUKER_HOOK_KEY] = {\n    listen: function listen(callback) {\n      listeners.push(callback);\n      messages.forEach(function (_ref) {\n        var type = _ref.type,\n            payload = _ref.payload;\n        return callback(type, payload);\n      });\n    }\n  };\n\n  initBackend({\n    on: function on(type, callback) {\n      if (!bridgeListeners[type]) bridgeListeners[type] = [];\n      bridgeListeners[type].push(callback);\n    },\n    send: function send(type, payload) {\n      console.log('------------> ' + type);\n      if (messages.length > MAX_MESSAGES_TO_CACHE) messages.shift();\n      messages.push({ type: type, payload: payload });\n      if (type === 'flush' && bridgeListeners['select-instance']) {\n        // bridgeListeners['select-instance'][0]('1:5');\n      }\n      listeners.forEach(function (l) {\n        return l(type, payload);\n      });\n    },\n    log: function log() {}\n  });\n});\n\n},{\"src/backend/hook\":6,\"src/backend/index\":7}]},{},[10]);\n";

var script = document.createElement('script');

script.textContent = vueDevtools.toString();
document.documentElement.appendChild(script);
script.parentNode.removeChild(script);

},{}]},{},[1]);
