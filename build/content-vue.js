(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

/* eslint-disable no-undef, vars-on-top */

var vueDevtools = "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nfunction encode (data, replacer, list, seen) {\n  var stored, key, value, i, l\n  var seenIndex = seen.get(data)\n  if (seenIndex != null) {\n    return seenIndex\n  }\n  var index = list.length\n  if (isPlainObject(data)) {\n    stored = {}\n    seen.set(data, index)\n    list.push(stored)\n    var keys = Object.keys(data)\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i]\n      value = data[key]\n      if (replacer) {\n        value = replacer.call(data, key, value)\n      }\n      stored[key] = encode(value, replacer, list, seen)\n    }\n  } else if (Array.isArray(data)) {\n    stored = []\n    seen.set(data, index)\n    list.push(stored)\n    for (i = 0, l = data.length; i < l; i++) {\n      value = data[i]\n      if (replacer) {\n       value = replacer.call(data, i, value)\n      }\n      stored[i] = encode(value, replacer, list, seen)\n    }\n  } else {\n    index = list.length\n    list.push(data)\n  }\n  return index\n}\n\nfunction decode (list, reviver) {\n  var i = list.length\n  var j, k, data, key, value\n  while (i--) {\n    var data = list[i]\n    if (isPlainObject(data)) {\n      var keys = Object.keys(data)\n      for (j = 0, k = keys.length; j < k; j++) {\n        key = keys[j]\n        value = list[data[key]]\n        if (reviver) value = reviver.call(data, key, value)\n        data[key] = value\n      }\n    } else if (Array.isArray(data)) {\n      for (j = 0, k = data.length; j < k; j++) {\n        value = list[data[j]]\n        if (reviver) value = reviver.call(data, j, value)\n        data[j] = value\n      }\n    }\n  }\n}\n\nfunction isPlainObject (obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]'\n}\n\nexports.stringify = function stringify (data, replacer, space) {\n  try {\n    return arguments.length === 1\n      ? JSON.stringify(data)\n      : JSON.stringify(data, replacer, space)\n  } catch (e) {\n    return exports.stringifyStrict(data, replacer, space)\n  }\n}\n\nexports.parse = function parse (data, reviver) {\n  var hasCircular = /^\\s/.test(data)\n  if (!hasCircular) {\n    return arguments.length === 1\n      ? JSON.parse(data)\n      : JSON.parse(data, reviver)\n  } else {\n    var list = JSON.parse(data)\n    decode(list, reviver)\n    return list[0]\n  }\n}\n\nexports.stringifyStrict = function (data, replacer, space) {\n  var list = []\n  encode(data, replacer, list, new Map())\n  return space\n    ? ' ' + JSON.stringify(list, null, space)\n    : ' ' + JSON.stringify(list)\n}\n\n},{}],2:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\nexports.default = BaseEmitter;\n\nvar _sanitize = require('./helpers/sanitize');\n\nvar _sanitize2 = _interopRequireDefault(_sanitize);\n\nvar _createMessenger = require('./helpers/createMessenger');\n\nvar _createMessenger2 = _interopRequireDefault(_createMessenger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction BaseEmitter() {\n  var message = (0, _createMessenger2.default)('BaseEmitter');\n\n  return function (data) {\n    return message((0, _sanitize2.default)(data));\n  };\n};\nmodule.exports = exports['default'];\n},{\"./helpers/createMessenger\":9,\"./helpers/sanitize\":10}],3:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\nexports.default = MachinaEmitter;\n\nvar _sanitize = require('./helpers/sanitize');\n\nvar _sanitize2 = _interopRequireDefault(_sanitize);\n\nvar _createMessenger = require('./helpers/createMessenger');\n\nvar _createMessenger2 = _interopRequireDefault(_createMessenger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction MachinaEmitter(machine) {\n  var message = (0, _createMessenger2.default)('MachinaEmitter');\n\n  machine.on('*', function (eventName, data) {\n    message({\n      type: 'Machina_' + eventName,\n      label: typeof machine.state === 'string' ? machine.state : '',\n      state: (0, _sanitize2.default)(machine.state),\n      data: (0, _sanitize2.default)(data)\n    });\n  });\n};\nmodule.exports = exports['default'];\n},{\"./helpers/createMessenger\":9,\"./helpers/sanitize\":10}],4:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = MobXEmitter;\n\nvar _sanitize = require('./helpers/sanitize');\n\nvar _sanitize2 = _interopRequireDefault(_sanitize);\n\nvar _createMessenger = require('./helpers/createMessenger');\n\nvar _createMessenger2 = _interopRequireDefault(_createMessenger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction MobXEmitter(spy, stores) {\n  var message = (0, _createMessenger2.default)('MobXEmitter');\n  var emit = function emit(data) {\n    return message((0, _sanitize2.default)(data));\n  };\n  var state = stores.reduce(function (result, store) {\n    result[store.constructor.name] = store;\n    return result;\n  }, {});\n  var indent = 0;\n\n  spy(function (event) {\n    var type = '@mobx_' + (event.type || 'spyReportEnd');\n\n    if (event.spyReportEnd) indent -= 1;\n\n    emit({\n      type: type,\n      state: state,\n      event: _extends({}, event, { indent: indent })\n    });\n\n    if (event.spyReportStart) indent += 1;\n  });\n};\nmodule.exports = exports['default'];\n},{\"./helpers/createMessenger\":9,\"./helpers/sanitize\":10}],5:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\nexports.throttle = exports.traverseReactTree = exports.Node = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = ReactEmitter;\n\nvar _createMessenger = require('./helpers/createMessenger');\n\nvar _createMessenger2 = _interopRequireDefault(_createMessenger);\n\nvar _sanitize = require('./helpers/sanitize');\n\nvar _sanitize2 = _interopRequireDefault(_sanitize);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\n// Implementation taken from https://github.com/facebook/react-devtools/blob/master/backend/attachRenderer.js#L175-L181\n// If this breaks make sure that it is in sync with the original\n\nvar tries = 5;\n\nvar Node = function Node() {\n  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  // eslint-disable-next-line\n  var _ref = data.props || {},\n      children = _ref.children,\n      otherProps = _objectWithoutProperties(_ref, ['children']);\n\n  return {\n    name: data.name,\n    props: (0, _sanitize2.default)(_extends({}, otherProps)),\n    state: (0, _sanitize2.default)(data.state),\n    children: []\n  };\n};\n\nexports.Node = Node;\nvar traverseReactTree = exports.traverseReactTree = function traverseReactTree(root, renderer, _ref2) {\n  var getData = _ref2.getData,\n      getData012 = _ref2.getData012,\n      getDataFiber = _ref2.getDataFiber,\n      getDisplayName = _ref2.getDisplayName;\n\n  if (!root) return {};\n\n  var isPre013 = !renderer.Reconciler;\n  var walkNode = function walkNode(internalInstance) {\n    var data = isPre013 ? getData012(internalInstance) : getData(internalInstance);\n    var item = Node(data);\n\n    if (data.children && Array.isArray(data.children)) {\n      item.children = data.children.map(function (child) {\n        return walkNode(child);\n      });\n    }\n    return item;\n  };\n\n  return walkNode(root);\n};\n\nvar throttle = exports.throttle = function throttle(func, wait, options) {\n  var context, args, result;\n  var timeout = null;\n  var previous = 0;\n  var throttleMeta = { calls: 0, components: [] };\n\n  var processThrottledCall = function processThrottledCall(_ref3) {\n    var data = _ref3.data;\n\n    throttleMeta.calls += 1;\n    data && data.name && throttleMeta.components.push(data.name);\n  };\n  var resetThrottleMeta = function resetThrottleMeta() {\n    throttleMeta = { calls: 0, components: [] };\n  };\n  var later = function later() {\n    previous = options.leading === false ? 0 : Date.now();\n    timeout = null;\n    result = func.apply(context, [throttleMeta].concat(args));\n    resetThrottleMeta();\n    if (!timeout) context = args = null;\n  };\n\n  if (!options) options = {};\n\n  return function () {\n    var now = Date.now();\n\n    processThrottledCall.apply(undefined, arguments);\n    if (!previous && options.leading === false) previous = now;\n\n    // eslint-disable-next-line\n    var remaining = wait - (now - previous);\n\n    context = this;\n    args = arguments;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, [throttleMeta].concat(args));\n      resetThrottleMeta();\n      if (!timeout) context = args = null;\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n};\n\nvar connect = function connect(callback) {\n  if (window.__REACT_DEVTOOLS_GLOBAL_HOOK__) {\n    callback(window.__REACT_DEVTOOLS_GLOBAL_HOOK__);\n    return;\n  }\n  if (tries >= 0) {\n    tries -= 1;\n    setTimeout(function () {\n      return connect(callback);\n    }, 1500);\n  }\n};\n\nfunction ReactEmitter() {\n  if (typeof window === 'undefined') return;\n\n  var postMessage = (0, _createMessenger2.default)('ReactEmitter');\n\n  connect(function (hook) {\n    var getState = function getState() {\n      return {};\n    };\n\n    hook.on('renderer-attached', function (attached) {\n      var helpers = attached.helpers,\n          renderer = attached.renderer;\n\n      var rootNode = null;\n\n      (function findRootNode() {\n        helpers.walkTree(function () {}, function (root) {\n          var rootData = hook.__helpers.getData(root);\n\n          rootNode = root;\n          if (rootData.name === 'TopLevelWrapper' && rootData.children && rootData.children.length === 1) {\n            root = rootData.children[0];\n          }\n          getState = function getState() {\n            return (0, _sanitize2.default)(traverseReactTree(root, renderer, hook.__helpers));\n          };\n          postMessage({\n            type: '@@react_root_detected',\n            state: getState()\n          });\n        });\n        if (rootNode === null) {\n          setTimeout(findRootNode, 300);\n        }\n      })();\n    });\n    hook.on('root', throttle(function (_ref4) {\n      var calls = _ref4.calls,\n          components = _ref4.components;\n\n      postMessage({\n        type: '@@react_root',\n        state: getState(),\n        calls: calls,\n        components: components\n      });\n    }), 100);\n    hook.on('mount', throttle(function (_ref5) {\n      var calls = _ref5.calls,\n          components = _ref5.components;\n\n      postMessage({\n        type: '@@react_mount',\n        state: getState(),\n        calls: calls,\n        components: components\n      });\n    }), 100);\n    hook.on('update', throttle(function (_ref6) {\n      var calls = _ref6.calls,\n          components = _ref6.components;\n\n      postMessage({\n        type: '@@react_update',\n        state: getState(),\n        calls: calls,\n        components: components\n      });\n    }), 100);\n    hook.on('unmount', throttle(function (_ref7) {\n      var calls = _ref7.calls,\n          components = _ref7.components;\n\n      postMessage({\n        type: '@@react_unmount',\n        state: getState(),\n        calls: calls,\n        components: components\n      });\n    }), 100);\n  });\n};\n},{\"./helpers/createMessenger\":9,\"./helpers/sanitize\":10}],6:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\nexports.default = ReduxEmitter;\n\nvar _sanitize = require('./helpers/sanitize');\n\nvar _sanitize2 = _interopRequireDefault(_sanitize);\n\nvar _createMessenger = require('./helpers/createMessenger');\n\nvar _createMessenger2 = _interopRequireDefault(_createMessenger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar NOOP = function NOOP() {\n  return function (noop) {\n    return noop;\n  };\n};\n\nfunction ReduxEmitter() {\n  var message = (0, _createMessenger2.default)('ReduxEmitter', 'Redux library');\n\n  return function middleware(_ref) {\n    var getState = _ref.getState,\n        dispatch = _ref.dispatch;\n\n    return function (next) {\n      return function (action) {\n        var result = next(action);\n\n        message({\n          state: (0, _sanitize2.default)(getState()),\n          type: '@redux_ACTION',\n          action: (0, _sanitize2.default)(action)\n        });\n        return result;\n      };\n    };\n  };\n};\nmodule.exports = exports['default'];\n},{\"./helpers/createMessenger\":9,\"./helpers/sanitize\":10}],7:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* eslint-disable max-len */\n\n\nexports.default = ReduxSagaEmitter;\n\nvar _sanitize = require('./helpers/sanitize');\n\nvar _sanitize2 = _interopRequireDefault(_sanitize);\n\nvar _createMessenger = require('./helpers/createMessenger');\n\nvar _createMessenger2 = _interopRequireDefault(_createMessenger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar store = null;\n\nvar getState = function getState() {\n  if (store) return store.getState();\n  return { '<unknown>': 'You forgot to call `emitter.setStore(<your store>)`. Please check https://github.com/krasimir/kuker-emitters' };\n};\n\nvar NOOP = { sagaMonitor: null, setStore: function setStore() {} };\n\nfunction ReduxSagaEmitter() {\n  var message = (0, _createMessenger2.default)('ReduxEmitter', 'Redux-Saga library');\n  var sendMessage = function sendMessage(data) {\n    message(_extends({\n      state: (0, _sanitize2.default)(getState())\n    }, data));\n  };\n\n  return {\n    sagaMonitor: {\n      effectTriggered: function effectTriggered(_ref) {\n        var effectId = _ref.effectId,\n            parentEffectId = _ref.parentEffectId,\n            label = _ref.label,\n            effect = _ref.effect;\n\n        sendMessage(_extends({\n          type: '@saga_effectTriggered'\n        }, (0, _sanitize2.default)({ effectId: effectId, parentEffectId: parentEffectId, label: label, effect: effect })));\n      },\n      effectResolved: function effectResolved(effectId, result) {\n        sendMessage(_extends({\n          type: '@saga_effectResolved'\n        }, (0, _sanitize2.default)({ effectId: effectId, result: result })));\n      },\n      effectRejected: function effectRejected(effectId, error) {\n\n        sendMessage(_extends({\n          type: '@saga_effectRejected'\n        }, (0, _sanitize2.default)({ effectId: effectId, error: error })));\n      },\n      effectCancelled: function effectCancelled(effectId) {\n        sendMessage({\n          type: '@saga_effectCancelled',\n          effectId: effectId\n        });\n      },\n      actionDispatched: function actionDispatched(action) {\n        sendMessage(_extends({\n          type: '@saga_actionDispatched'\n        }, (0, _sanitize2.default)({ action: action })));\n      }\n    },\n    setStore: function setStore(s) {\n      store = s;\n    }\n  };\n};\nmodule.exports = exports['default'];\n},{\"./helpers/createMessenger\":9,\"./helpers/sanitize\":10}],8:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _sanitize = require('./helpers/sanitize');\n\nvar _sanitize2 = _interopRequireDefault(_sanitize);\n\nvar _createMessenger = require('./helpers/createMessenger');\n\nvar _createMessenger2 = _interopRequireDefault(_createMessenger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Machine;\n\nvar formatYielded = function formatYielded(yielded) {\n  var y = yielded;\n\n  if (yielded && yielded.__type === 'call') {\n    var funcName = yielded.func.name;\n\n    if (funcName === '') {\n      funcName = '<anonymous>';\n    };\n    try {\n      y = (0, _sanitize2.default)(yielded);\n    } catch (error) {\n      y = { __type: 'call' };\n    }\n    y.func = funcName;\n  }\n\n  return y;\n};\n\nvar getMetaInfo = function getMetaInfo(meta) {\n  return Object.assign({}, meta, {\n    middlewares: Machine.middlewares.length\n  });\n};\n\nvar StentEmitter = function StentEmitter() {\n  var message = (0, _createMessenger2.default)('StentEmitter');\n  var postMessage = function postMessage(data) {\n    var machines = Object.keys(Machine.machines).map(function (name) {\n      return { name: name, state: (0, _sanitize2.default)(Machine.machines[name].state) };\n    });\n\n    message(_extends({ state: machines }, data));\n  };\n\n  return {\n    __sanitize: _sanitize2.default,\n    __formatYielded: formatYielded,\n    __message: message,\n    __initialize: function __initialize(m) {\n      Machine = m;\n    },\n    onMachineCreated: function onMachineCreated(machine) {\n      postMessage({\n        type: 'onMachineCreated',\n        machine: (0, _sanitize2.default)(machine),\n        meta: getMetaInfo()\n      });\n    },\n    onActionDispatched: function onActionDispatched(actionName) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      postMessage({\n        type: 'onActionDispatched',\n        actionName: actionName,\n        args: (0, _sanitize2.default)(args),\n        machine: (0, _sanitize2.default)(this),\n        meta: getMetaInfo()\n      });\n    },\n    onActionProcessed: function onActionProcessed(actionName) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      postMessage({\n        type: 'onActionProcessed',\n        actionName: actionName,\n        args: (0, _sanitize2.default)(args),\n        machine: (0, _sanitize2.default)(this),\n        meta: getMetaInfo()\n      });\n    },\n    onStateWillChange: function onStateWillChange() {\n      postMessage({\n        type: 'onStateWillChange',\n        machine: (0, _sanitize2.default)(this),\n        meta: getMetaInfo()\n      });\n    },\n    onStateChanged: function onStateChanged() {\n      postMessage({\n        type: 'onStateChanged',\n        machine: (0, _sanitize2.default)(this),\n        meta: getMetaInfo()\n      });\n    },\n    onGeneratorStep: function onGeneratorStep(yielded) {\n      postMessage({\n        type: 'onGeneratorStep',\n        yielded: formatYielded(yielded),\n        meta: getMetaInfo()\n      });\n    },\n    onGeneratorEnd: function onGeneratorEnd(value) {\n      postMessage({\n        type: 'onGeneratorEnd',\n        value: (0, _sanitize2.default)(value),\n        meta: getMetaInfo()\n      });\n    },\n    onGeneratorResumed: function onGeneratorResumed(value) {\n      postMessage({\n        type: 'onGeneratorResumed',\n        value: (0, _sanitize2.default)(value),\n        meta: getMetaInfo()\n      });\n    },\n    onMachineConnected: function onMachineConnected(machines, meta) {\n      postMessage({\n        type: 'onMachineConnected',\n        meta: getMetaInfo(_extends({}, meta, { machines: (0, _sanitize2.default)(machines) }))\n      });\n    },\n    onMachineDisconnected: function onMachineDisconnected(machines, meta) {\n      postMessage({\n        type: 'onMachineDisconnected',\n        meta: getMetaInfo(_extends({}, meta, { machines: (0, _sanitize2.default)(machines) }))\n      });\n    },\n    onMiddlewareRegister: function onMiddlewareRegister() {}\n  };\n};\n\nexports.default = StentEmitter;\nmodule.exports = exports['default'];\n},{\"./helpers/createMessenger\":9,\"./helpers/sanitize\":10}],9:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = createMessenger;\n/* eslint-disable vars-on-top */\nvar PORT = exports.PORT = 8228;\nvar KUKER_EVENT = 'kuker-event';\nvar NODE_ORIGIN = 'node (PORT: ' + PORT + ')';\n\nvar isDefined = function isDefined(what) {\n  return typeof what !== 'undefined';\n};\n\nfunction getOrigin() {\n  if (isDefined(location) && isDefined(location.protocol) && isDefined(location.host)) {\n    return location.protocol + '//' + location.host;\n  }\n  return 'unknown';\n}\n\nvar messagesBeforeSetup = [];\nvar connections = null;\nvar app = null;\nvar isThereAnySocketServer = function isThereAnySocketServer() {\n  return app !== null;\n};\nvar isTheServerReady = false;\n\nfunction createMessenger(emitterName) {\n  var emitterDescription = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n\n  function enhanceEvent(origin, data) {\n    return _extends({\n      kuker: true,\n      time: new Date().getTime(),\n      origin: origin,\n      emitter: emitterName\n    }, data);\n  }\n  var socketPostMessage = function socketPostMessage(data) {\n    if (isThereAnySocketServer() && connections !== null) {\n      Object.keys(connections).forEach(function (id) {\n        return connections[id].emit(KUKER_EVENT, [enhanceEvent(NODE_ORIGIN, data)]);\n      });\n    } else {\n      messagesBeforeSetup.push(data);\n    }\n  };\n  var browserPostMessage = function browserPostMessage(data) {\n    window.postMessage(enhanceEvent(getOrigin(), data), '*');\n  };\n\n  // in node\n  if (typeof window === 'undefined') {\n    if (isThereAnySocketServer()) {\n      socketPostMessage({ type: 'NEW_EMITTER', emitterDescription: emitterDescription });\n    } else {\n      if (isTheServerReady) {\n        return socketPostMessage;\n      }\n      var r = 'require';\n      var socketIO = module[r]('socket.io');\n      var http = module[r]('http');\n\n      app = http.createServer(function (req, res) {\n        res.writeHead(200);\n        res.end('Kuker: Hi!');\n      });\n      var io = socketIO(app);\n\n      io.on('connection', function (socket) {\n        if (connections === null) connections = {};\n        connections[socket.id] = socket;\n        socket.on('disconnect', function (reason) {\n          delete connections[socket.id];\n        });\n        // the very first client receives the pending messages\n        // for the rest ... sorry :)\n        if (messagesBeforeSetup.length > 0) {\n          socketPostMessage({ type: 'NEW_EMITTER', emitterDescription: emitterDescription });\n          messagesBeforeSetup.forEach(function (data) {\n            return socketPostMessage(data);\n          });\n          messagesBeforeSetup = [];\n        }\n        console.log('Kuker(Messenger): client connected (' + Object.keys(connections).length + ' in total)');\n      });\n\n      app.listen(PORT);\n      isTheServerReady = true;\n      console.log('Kuker(Messenger): server running at ' + PORT);\n    }\n\n    return socketPostMessage;\n  }\n\n  // in the browser\n  browserPostMessage({ type: 'NEW_EMITTER', emitterDescription: emitterDescription });\n  return browserPostMessage;\n};\n},{}],10:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\nexports.default = sanitize;\n\nvar _CircularJSON = require('./vendors/CircularJSON');\n\nvar _SerializeError = require('./vendors/SerializeError');\n\nvar _SerializeError2 = _interopRequireDefault(_SerializeError);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction sanitize(something) {\n  var showErrorInConsole = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var result;\n\n  try {\n    result = JSON.parse((0, _CircularJSON.stringify)(something, function (key, value) {\n      if (typeof value === 'function') {\n        return { __func: value.name === '' ? '<anonymous>' : value.name };\n      }\n      if (value instanceof Error) {\n        return (0, _SerializeError2.default)(value);\n      }\n      return value;\n    }));\n  } catch (error) {\n    if (showErrorInConsole) {\n      console.log(error);\n    }\n    result = null;\n  }\n  return result;\n}\nmodule.exports = exports['default'];\n},{\"./vendors/CircularJSON\":11,\"./vendors/SerializeError\":12}],11:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\nCopyright (C) 2013-2017 by Andrea Giammarchi - @WebReflection\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\nvar\n// should be a not so common char\n// possibly one JSON does not encode\n// possibly one encodeURIComponent does not encode\n// right now this char is '~' but this might change in the future\nspecialChar = '~',\n    safeSpecialChar = '\\\\x' + ('0' + specialChar.charCodeAt(0).toString(16)).slice(-2),\n    escapedSafeSpecialChar = '\\\\' + safeSpecialChar,\n    specialCharRG = new RegExp(safeSpecialChar, 'g'),\n    safeSpecialCharRG = new RegExp(escapedSafeSpecialChar, 'g'),\n    safeStartWithSpecialCharRG = new RegExp('(?:^|([^\\\\\\\\]))' + escapedSafeSpecialChar),\n    indexOf = [].indexOf || function (v) {\n  for (var i = this.length; i-- && this[i] !== v;) {}\n  return i;\n},\n    $String = String // there's no way to drop warnings in JSHint\n// about new String ... well, I need that here!\n// faked, and happy linter!\n;\n\nfunction generateReplacer(value, replacer, resolve) {\n  var inspect = !!replacer,\n      path = [],\n      all = [value],\n      seen = [value],\n      mapp = [resolve ? specialChar : '[Circular]'],\n      last = value,\n      lvl = 1,\n      i,\n      fn;\n  if (inspect) {\n    fn = (typeof replacer === 'undefined' ? 'undefined' : _typeof(replacer)) === 'object' ? function (key, value) {\n      return key !== '' && replacer.indexOf(key) < 0 ? void 0 : value;\n    } : replacer;\n  }\n  return function (key, value) {\n    // the replacer has rights to decide\n    // if a new object should be returned\n    // or if there's some key to drop\n    // let's call it here rather than \"too late\"\n    if (inspect) value = fn.call(this, key, value);\n\n    // did you know ? Safari passes keys as integers for arrays\n    // which means if (key) when key === 0 won't pass the check\n    if (key !== '') {\n      if (last !== this) {\n        i = lvl - indexOf.call(all, this) - 1;\n        lvl -= i;\n        all.splice(lvl, all.length);\n        path.splice(lvl - 1, path.length);\n        last = this;\n      }\n      // console.log(lvl, key, path);\n      if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value) {\n        // if object isn't referring to parent object, add to the\n        // object path stack. Otherwise it is already there.\n        if (indexOf.call(all, value) < 0) {\n          all.push(last = value);\n        }\n        lvl = all.length;\n        i = indexOf.call(seen, value);\n        if (i < 0) {\n          i = seen.push(value) - 1;\n          if (resolve) {\n            // key cannot contain specialChar but could be not a string\n            path.push(('' + key).replace(specialCharRG, safeSpecialChar));\n            mapp[i] = specialChar + path.join(specialChar);\n          } else {\n            mapp[i] = mapp[0];\n          }\n        } else {\n          value = mapp[i];\n        }\n      } else {\n        if (typeof value === 'string' && resolve) {\n          // ensure no special char involved on deserialization\n          // in this case only first char is important\n          // no need to replace all value (better performance)\n          value = value.replace(safeSpecialChar, escapedSafeSpecialChar).replace(specialChar, safeSpecialChar);\n        }\n      }\n    }\n    return value;\n  };\n}\n\nfunction retrieveFromPath(current, keys) {\n  for (var i = 0, length = keys.length; i < length; current = current[\n  // keys should be normalized back here\n  keys[i++].replace(safeSpecialCharRG, specialChar)]) {}\n  return current;\n}\n\nfunction generateReviver(reviver) {\n  return function (key, value) {\n    var isString = typeof value === 'string';\n    if (isString && value.charAt(0) === specialChar) {\n      return new $String(value.slice(1));\n    }\n    if (key === '') value = regenerate(value, value, {});\n    // again, only one needed, do not use the RegExp for this replacement\n    // only keys need the RegExp\n    if (isString) value = value.replace(safeStartWithSpecialCharRG, '$1' + specialChar).replace(escapedSafeSpecialChar, safeSpecialChar);\n    return reviver ? reviver.call(this, key, value) : value;\n  };\n}\n\nfunction regenerateArray(root, current, retrieve) {\n  for (var i = 0, length = current.length; i < length; i++) {\n    current[i] = regenerate(root, current[i], retrieve);\n  }\n  return current;\n}\n\nfunction regenerateObject(root, current, retrieve) {\n  for (var key in current) {\n    if (current.hasOwnProperty(key)) {\n      current[key] = regenerate(root, current[key], retrieve);\n    }\n  }\n  return current;\n}\n\nfunction regenerate(root, current, retrieve) {\n  return current instanceof Array ?\n  // fast Array reconstruction\n  regenerateArray(root, current, retrieve) : current instanceof $String ?\n  // root is an empty string\n  current.length ? retrieve.hasOwnProperty(current) ? retrieve[current] : retrieve[current] = retrieveFromPath(root, current.split(specialChar)) : root : current instanceof Object ?\n  // dedicated Object parser\n  regenerateObject(root, current, retrieve) :\n  // value as it is\n  current;\n}\n\nfunction stringifyRecursion(value, replacer, space, doNotResolve) {\n  return JSON.stringify(value, generateReplacer(value, replacer, !doNotResolve), space);\n}\n\nfunction parseRecursion(text, reviver) {\n  return JSON.parse(text, generateReviver(reviver));\n}\n\nexports.default = {\n  stringify: stringifyRecursion,\n  parse: parseRecursion\n};\nmodule.exports = exports['default'];\n},{}],12:[function(require,module,exports){\n// Credits: https://github.com/sindresorhus/serialize-error\n\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nmodule.exports = function (value) {\n\tif ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n\t\treturn destroyCircular(value, []);\n\t}\n\n\t// People sometimes throw things besides Error objects, so…\n\n\tif (typeof value === 'function') {\n\t\t// JSON.stringify discards functions. We do too, unless a function is thrown directly.\n\t\treturn '[Function: ' + (value.name || 'anonymous') + ']';\n\t}\n\n\treturn value;\n};\n\n// https://www.npmjs.com/package/destroy-circular\nfunction destroyCircular(from, seen) {\n\tvar to = Array.isArray(from) ? [] : {};\n\n\tseen.push(from);\n\n\tfor (var _iterator = Object.keys(from), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n\t\tvar _ref;\n\n\t\tif (_isArray) {\n\t\t\tif (_i >= _iterator.length) break;\n\t\t\t_ref = _iterator[_i++];\n\t\t} else {\n\t\t\t_i = _iterator.next();\n\t\t\tif (_i.done) break;\n\t\t\t_ref = _i.value;\n\t\t}\n\n\t\tvar key = _ref;\n\n\t\tvar value = from[key];\n\n\t\tif (typeof value === 'function') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!value || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object') {\n\t\t\tto[key] = value;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (seen.indexOf(from[key]) === -1) {\n\t\t\tto[key] = destroyCircular(from[key], seen.slice(0));\n\t\t\tcontinue;\n\t\t}\n\n\t\tto[key] = '[Circular]';\n\t}\n\n\tif (typeof from.name === 'string') {\n\t\tto.name = from.name;\n\t}\n\n\tif (typeof from.message === 'string') {\n\t\tto.message = from.message;\n\t}\n\n\tif (typeof from.stack === 'string') {\n\t\tto.stack = from.stack;\n\t}\n\n\treturn to;\n}\n},{}],13:[function(require,module,exports){\n'use strict';\n\nexports.__esModule = true;\n\nvar _BaseEmitter = require('./BaseEmitter');\n\nvar _BaseEmitter2 = _interopRequireDefault(_BaseEmitter);\n\nvar _MachinaEmitter = require('./MachinaEmitter');\n\nvar _MachinaEmitter2 = _interopRequireDefault(_MachinaEmitter);\n\nvar _ReduxEmitter = require('./ReduxEmitter');\n\nvar _ReduxEmitter2 = _interopRequireDefault(_ReduxEmitter);\n\nvar _ReduxSagaEmitter = require('./ReduxSagaEmitter');\n\nvar _ReduxSagaEmitter2 = _interopRequireDefault(_ReduxSagaEmitter);\n\nvar _StentEmitter = require('./StentEmitter');\n\nvar _StentEmitter2 = _interopRequireDefault(_StentEmitter);\n\nvar _MobXEmitter = require('./MobXEmitter');\n\nvar _MobXEmitter2 = _interopRequireDefault(_MobXEmitter);\n\nvar _ReactEmitter = require('./ReactEmitter');\n\nvar _ReactEmitter2 = _interopRequireDefault(_ReactEmitter);\n\nvar _createMessenger = require('./helpers/createMessenger');\n\nvar _createMessenger2 = _interopRequireDefault(_createMessenger);\n\nvar _sanitize = require('./helpers/sanitize');\n\nvar _sanitize2 = _interopRequireDefault(_sanitize);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n  BaseEmitter: _BaseEmitter2.default,\n  MachinaEmitter: _MachinaEmitter2.default,\n  ReduxEmitter: _ReduxEmitter2.default,\n  ReduxSagaEmitter: _ReduxSagaEmitter2.default,\n  StentEmitter: _StentEmitter2.default,\n  MobXEmitter: _MobXEmitter2.default,\n  ReactEmitter: _ReactEmitter2.default,\n\n  createMessenger: _createMessenger2.default,\n  sanitize: _sanitize2.default\n};\nmodule.exports = exports['default'];\n},{\"./BaseEmitter\":2,\"./MachinaEmitter\":3,\"./MobXEmitter\":4,\"./ReactEmitter\":5,\"./ReduxEmitter\":6,\"./ReduxSagaEmitter\":7,\"./StentEmitter\":8,\"./helpers/createMessenger\":9,\"./helpers/sanitize\":10}],14:[function(require,module,exports){\n(function (process){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n}).call(this,require('_process'))\n},{\"_process\":15}],15:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],16:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initEventsBackend = initEventsBackend;\n\nvar _util = require('../util');\n\nvar _index = require('./index');\n\nvar internalRE = /^(?:pre-)?hook:/;\n\nfunction initEventsBackend(Vue, bridge) {\n  var recording = true;\n\n  bridge.on('events:toggle-recording', function (enabled) {\n    recording = enabled;\n  });\n\n  function logEvent(vm, type, eventName, payload) {\n    // The string check is important for compat with 1.x where the first\n    // argument may be an object instead of a string.\n    // this also ensures the event is only logged for direct $emit (source)\n    // instead of by $dispatch/$broadcast\n    if (typeof eventName === 'string' && !internalRE.test(eventName)) {\n      bridge.send('event:triggered', (0, _util.stringify)({\n        eventName: eventName,\n        type: type,\n        payload: payload,\n        instanceId: vm._uid,\n        instanceName: (0, _index.getInstanceName)(vm._self || vm),\n        timestamp: Date.now()\n      }));\n    }\n  }\n\n  function wrap(method) {\n    var original = Vue.prototype[method];\n    if (original) {\n      Vue.prototype[method] = function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var res = original.apply(this, args);\n        if (recording) {\n          logEvent(this, method, args[0], args.slice(1));\n        }\n        return res;\n      };\n    }\n  }\n\n  wrap('$emit');\n  wrap('$broadcast');\n  wrap('$dispatch');\n}\n\n},{\"../util\":21,\"./index\":19}],17:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.highlight = highlight;\nexports.unHighlight = unHighlight;\nexports.getInstanceRect = getInstanceRect;\n\nvar _util = require('../util');\n\nvar overlay = document.createElement('div');\noverlay.style.backgroundColor = 'rgba(104, 182, 255, 0.35)';\noverlay.style.position = 'fixed';\noverlay.style.zIndex = '99999999999999';\noverlay.style.pointerEvents = 'none';\n\n/**\n * Highlight an instance.\n *\n * @param {Vue} instance\n */\n\nfunction highlight(instance) {\n  if (!instance) return;\n  var rect = getInstanceRect(instance);\n  if (rect) {\n    showOverlay(rect);\n  }\n}\n\n/**\n * Remove highlight overlay.\n */\n\nfunction unHighlight() {\n  if (overlay.parentNode) {\n    document.body.removeChild(overlay);\n  }\n}\n\n/**\n * Get the client rect for an instance.\n *\n * @param {Vue} instance\n * @return {Object}\n */\n\nfunction getInstanceRect(instance) {\n  if (!(0, _util.inDoc)(instance.$el)) {\n    return;\n  }\n  if (instance._isFragment) {\n    return getFragmentRect(instance);\n  } else if (instance.$el.nodeType === 1) {\n    return instance.$el.getBoundingClientRect();\n  }\n}\n\n/**\n * Highlight a fragment instance.\n * Loop over its node range and determine its bounding box.\n *\n * @param {Vue} instance\n * @return {Object}\n */\n\nfunction getFragmentRect(_ref) {\n  var _fragmentStart = _ref._fragmentStart,\n      _fragmentEnd = _ref._fragmentEnd;\n\n  var top = void 0,\n      bottom = void 0,\n      left = void 0,\n      right = void 0;\n  util().mapNodeRange(_fragmentStart, _fragmentEnd, function (node) {\n    var rect = void 0;\n    if (node.nodeType === 1 || node.getBoundingClientRect) {\n      rect = node.getBoundingClientRect();\n    } else if (node.nodeType === 3 && node.data.trim()) {\n      rect = getTextRect(node);\n    }\n    if (rect) {\n      if (!top || rect.top < top) {\n        top = rect.top;\n      }\n      if (!bottom || rect.bottom > bottom) {\n        bottom = rect.bottom;\n      }\n      if (!left || rect.left < left) {\n        left = rect.left;\n      }\n      if (!right || rect.right > right) {\n        right = rect.right;\n      }\n    }\n  });\n  return {\n    top: top,\n    left: left,\n    width: right - left,\n    height: bottom - top\n  };\n}\n\n/**\n * Get the bounding rect for a text node using a Range.\n *\n * @param {Text} node\n * @return {Rect}\n */\n\nvar range = document.createRange();\nfunction getTextRect(node) {\n  range.selectNode(node);\n  return range.getBoundingClientRect();\n}\n\n/**\n * Display the overlay with given rect.\n *\n * @param {Rect}\n */\n\nfunction showOverlay(_ref2) {\n  var _ref2$width = _ref2.width,\n      width = _ref2$width === undefined ? 0 : _ref2$width,\n      _ref2$height = _ref2.height,\n      height = _ref2$height === undefined ? 0 : _ref2$height,\n      _ref2$top = _ref2.top,\n      top = _ref2$top === undefined ? 0 : _ref2$top,\n      _ref2$left = _ref2.left,\n      left = _ref2$left === undefined ? 0 : _ref2$left;\n\n  overlay.style.width = ~~width + 'px';\n  overlay.style.height = ~~height + 'px';\n  overlay.style.top = ~~top + 'px';\n  overlay.style.left = ~~left + 'px';\n  document.body.appendChild(overlay);\n}\n\n/**\n * Get Vue's util\n */\n\nfunction util() {\n  return window.__VUE_DEVTOOLS_GLOBAL_HOOK__.Vue.util;\n}\n\n},{\"../util\":21}],18:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.installHook = installHook;\n// this script is injected into every page.\n\n/**\n * Install the hook on window, which is an event emitter.\n * Note because Chrome content scripts cannot directly modify the window object,\n * we are evaling this function by inserting a script tag. That's why we have\n * to inline the whole event emitter implementation here.\n *\n * @param {Window} window\n */\n\nfunction installHook(window) {\n  var listeners = {};\n\n  var hook = {\n    Vue: null,\n\n    on: function on(event, fn) {\n      event = '$' + event;(listeners[event] || (listeners[event] = [])).push(fn);\n    },\n    once: function once(event, fn) {\n      event = '$' + event;\n      function on() {\n        this.off(event, on);\n        fn.apply(this, arguments);\n      }\n      ;(listeners[event] || (listeners[event] = [])).push(on);\n    },\n    off: function off(event, fn) {\n      event = '$' + event;\n      if (!arguments.length) {\n        listeners = {};\n      } else {\n        var cbs = listeners[event];\n        if (cbs) {\n          if (!fn) {\n            listeners[event] = null;\n          } else {\n            for (var i = 0, l = cbs.length; i < l; i++) {\n              var cb = cbs[i];\n              if (cb === fn || cb.fn === fn) {\n                cbs.splice(i, 1);\n                break;\n              }\n            }\n          }\n        }\n      }\n    },\n    emit: function emit(event) {\n      event = '$' + event;\n      var cbs = listeners[event];\n      if (cbs) {\n        var args = [].slice.call(arguments, 1);\n        cbs = cbs.slice();\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i].apply(this, args);\n        }\n      }\n    }\n  };\n\n  hook.once('init', function (Vue) {\n    hook.Vue = Vue;\n  });\n\n  hook.once('vuex:init', function (store) {\n    hook.store = store;\n  });\n\n  Object.defineProperty(window, '__VUE_DEVTOOLS_GLOBAL_HOOK__', {\n    get: function get() {\n      return hook;\n    }\n  });\n}\n\n},{}],19:[function(require,module,exports){\n(function (process){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initBackend = initBackend;\nexports.getInstanceDetails = getInstanceDetails;\nexports.getInstanceName = getInstanceName;\n\nvar _highlighter = require('./highlighter');\n\nvar _vuex = require('./vuex');\n\nvar _events = require('./events');\n\nvar _util = require('../util');\n\nvar _path2 = require('path');\n\nvar _path3 = _interopRequireDefault(_path2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Use a custom basename functions instead of the shimed version\n// because it doesn't work on Windows\nfunction basename(filename, ext) {\n  return _path3.default.basename(filename.replace(/^[a-zA-Z]:/, '').replace(/\\\\/g, '/'), ext);\n}\n\n// hook should have been injected before this executes.\n// This is the backend that is injected into the page that a Vue app lives in\n// when the Vue Devtools panel is activated.\n\nvar hook = window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\nvar rootInstances = [];\nvar propModes = ['default', 'sync', 'once'];\n\nvar instanceMap = window.__VUE_DEVTOOLS_INSTANCE_MAP__ = new Map();\nvar consoleBoundInstances = Array(5);\nvar currentInspectedId = void 0;\nvar bridge = void 0;\nvar filter = '';\nvar captureCount = 0;\nvar isLegacy = false;\nvar rootUID = 0;\n\nfunction initBackend(_bridge) {\n  bridge = _bridge;\n  if (hook.Vue) {\n    isLegacy = hook.Vue.version && hook.Vue.version.split('.')[0] === '1';\n    connect();\n  } else {\n    hook.once('init', connect);\n  }\n}\n\nfunction connect() {\n  hook.currentTab = 'components';\n  bridge.on('switch-tab', function (tab) {\n    hook.currentTab = tab;\n    if (tab === 'components') {\n      flush();\n    }\n  });\n\n  // the backend may get injected to the same page multiple times\n  // if the user closes and reopens the devtools.\n  // make sure there's only one flush listener.\n  hook.off('flush');\n  hook.on('flush', function () {\n    if (hook.currentTab === 'components') {\n      flush();\n    }\n  });\n\n  bridge.on('select-instance', function (id) {\n    currentInspectedId = id;\n    var instance = instanceMap.get(id);\n    if (instance) {\n      scrollIntoView(instance);\n      (0, _highlighter.highlight)(instance);\n    }\n    bindToConsole(instance);\n    flush();\n    bridge.send('instance-details', (0, _util.stringify)(getInstanceDetails(id)));\n  });\n\n  bridge.on('filter-instances', function (_filter) {\n    filter = _filter.toLowerCase();\n    flush();\n  });\n\n  bridge.on('refresh', scan);\n  bridge.on('enter-instance', function (id) {\n    return (0, _highlighter.highlight)(instanceMap.get(id));\n  });\n  bridge.on('leave-instance', _highlighter.unHighlight);\n\n  // vuex\n  if (hook.store) {\n    (0, _vuex.initVuexBackend)(hook, bridge);\n  } else {\n    hook.once('vuex:init', function (store) {\n      (0, _vuex.initVuexBackend)(hook, bridge);\n    });\n  }\n\n  // events\n  (0, _events.initEventsBackend)(hook.Vue, bridge);\n\n  bridge.log('backend ready.');\n  bridge.send('ready', hook.Vue.version);\n  console.log('%c vue-devtools %c Detected Vue v' + hook.Vue.version + ' %c', 'background:#35495e ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff', 'background:#41b883 ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff', 'background:transparent');\n  scan();\n}\n\n/**\n * Scan the page for root level Vue instances.\n */\n\nfunction scan() {\n  rootInstances.length = 0;\n  var inFragment = false;\n  var currentFragment = null;\n  walk(document, function (node) {\n    if (inFragment) {\n      if (node === currentFragment._fragmentEnd) {\n        inFragment = false;\n        currentFragment = null;\n      }\n      return true;\n    }\n    var instance = node.__vue__;\n    if (instance) {\n      if (instance._isFragment) {\n        inFragment = true;\n        currentFragment = instance;\n      }\n\n      // respect Vue.config.devtools option\n      var baseVue = instance.constructor;\n      while (baseVue.super) {\n        baseVue = baseVue.super;\n      }\n      if (baseVue.config && baseVue.config.devtools) {\n        // give a unique id to root instance so we can\n        // 'namespace' its children\n        if (typeof instance.__VUE_DEVTOOLS_ROOT_UID__ === 'undefined') {\n          instance.__VUE_DEVTOOLS_ROOT_UID__ = ++rootUID;\n        }\n        rootInstances.push(instance);\n      }\n\n      return true;\n    }\n  });\n  flush();\n}\n\n/**\n * DOM walk helper\n *\n * @param {NodeList} nodes\n * @param {Function} fn\n */\n\nfunction walk(node, fn) {\n  if (node.childNodes) {\n    for (var i = 0, l = node.childNodes.length; i < l; i++) {\n      var child = node.childNodes[i];\n      var stop = fn(child);\n      if (!stop) {\n        walk(child, fn);\n      }\n    }\n  }\n\n  // also walk shadow DOM\n  if (node.shadowRoot) {\n    walk(node.shadowRoot, fn);\n  }\n}\n\n/**\n * Called on every Vue.js batcher flush cycle.\n * Capture current component tree structure and the state\n * of the current inspected instance (if present) and\n * send it to the devtools.\n */\n\nfunction flush() {\n  var start = void 0;\n  if (process.env.NODE_ENV !== 'production') {\n    captureCount = 0;\n    start = window.performance.now();\n  }\n  var payload = (0, _util.stringify)({\n    inspectedInstance: getInstanceDetails(currentInspectedId),\n    instances: findQualifiedChildrenFromList(rootInstances)\n  });\n  if (process.env.NODE_ENV !== 'production') {\n    console.log('[flush] serialized ' + captureCount + ' instances, took ' + (window.performance.now() - start) + 'ms.');\n  }\n  bridge.send('flush', payload);\n}\n\n/**\n * Iterate through an array of instances and flatten it into\n * an array of qualified instances. This is a depth-first\n * traversal - e.g. if an instance is not matched, we will\n * recursively go deeper until a qualified child is found.\n *\n * @param {Array} instances\n * @return {Array}\n */\n\nfunction findQualifiedChildrenFromList(instances) {\n  instances = instances.filter(function (child) {\n    return !child._isBeingDestroyed;\n  });\n  return !filter ? instances.map(capture) : Array.prototype.concat.apply([], instances.map(findQualifiedChildren));\n}\n\n/**\n * Find qualified children from a single instance.\n * If the instance itself is qualified, just return itself.\n * This is ok because [].concat works in both cases.\n *\n * @param {Vue} instance\n * @return {Vue|Array}\n */\n\nfunction findQualifiedChildren(instance) {\n  return isQualified(instance) ? capture(instance) : findQualifiedChildrenFromList(instance.$children);\n}\n\n/**\n * Check if an instance is qualified.\n *\n * @param {Vue} instance\n * @return {Boolean}\n */\n\nfunction isQualified(instance) {\n  var name = getInstanceName(instance).toLowerCase();\n  return name.indexOf(filter) > -1;\n}\n\n/**\n * Capture the meta information of an instance. (recursive)\n *\n * @param {Vue} instance\n * @return {Object}\n */\n\nfunction capture(instance, _, list) {\n  if (process.env.NODE_ENV !== 'production') {\n    captureCount++;\n  }\n  // instance._uid is not reliable in devtools as there\n  // may be 2 roots with same _uid which causes unexpected\n  // behaviour\n  instance.__VUE_DEVTOOLS_UID__ = getUniqueId(instance);\n  mark(instance);\n  var ret = {\n    id: instance.__VUE_DEVTOOLS_UID__,\n    name: getInstanceName(instance),\n    inactive: !!instance._inactive,\n    isFragment: !!instance._isFragment,\n    children: instance.$children.filter(function (child) {\n      return !child._isBeingDestroyed;\n    }).map(capture)\n    // record screen position to ensure correct ordering\n  };if ((!list || list.length > 1) && !instance._inactive) {\n    var rect = (0, _highlighter.getInstanceRect)(instance);\n    ret.top = rect ? rect.top : Infinity;\n  } else {\n    ret.top = Infinity;\n  }\n  // check if instance is available in console\n  var consoleId = consoleBoundInstances.indexOf(instance.__VUE_DEVTOOLS_UID__);\n  ret.consoleId = consoleId > -1 ? '$vm' + consoleId : null;\n  // check router view\n  var isRouterView2 = instance.$vnode && instance.$vnode.data.routerView;\n  if (instance._routerView || isRouterView2) {\n    ret.isRouterView = true;\n    if (!instance._inactive && instance.$route) {\n      var matched = instance.$route.matched;\n      var depth = isRouterView2 ? instance.$vnode.data.routerViewDepth : instance._routerView.depth;\n      ret.matchedRouteSegment = matched && matched[depth] && (isRouterView2 ? matched[depth].path : matched[depth].handler.path);\n    }\n  }\n  return ret;\n}\n\n/**\n * Mark an instance as captured and store it in the instance map.\n *\n * @param {Vue} instance\n */\n\nfunction mark(instance) {\n  if (!instanceMap.has(instance.__VUE_DEVTOOLS_UID__)) {\n    instanceMap.set(instance.__VUE_DEVTOOLS_UID__, instance);\n    instance.$on('hook:beforeDestroy', function () {\n      instanceMap.delete(instance.__VUE_DEVTOOLS_UID__);\n    });\n  }\n}\n\n/**\n * Get the detailed information of an inspected instance.\n *\n * @param {Number} id\n */\n\nfunction getInstanceDetails(id) {\n  var instance = instanceMap.get(id);\n  if (!instance) {\n    return {};\n  } else {\n    return {\n      id: id,\n      name: getInstanceName(instance),\n      state: processProps(instance).concat(processState(instance), processComputed(instance), processRouteContext(instance), processVuexGetters(instance), processFirebaseBindings(instance), processObservables(instance))\n    };\n  }\n}\n\n/**\n * Get the appropriate display name for an instance.\n *\n * @param {Vue} instance\n * @return {String}\n */\n\nfunction getInstanceName(instance) {\n  var name = instance.$options.name || instance.$options._componentTag;\n  if (name) {\n    return (0, _util.classify)(name);\n  }\n  var file = instance.$options.__file; // injected by vue-loader\n  if (file) {\n    return (0, _util.classify)(basename(file, '.vue'));\n  }\n  return instance.$root === instance ? 'Root' : 'Anonymous Component';\n}\n\n/**\n * Process the props of an instance.\n * Make sure return a plain object because window.postMessage()\n * will throw an Error if the passed object contains Functions.\n *\n * @param {Vue} instance\n * @return {Array}\n */\n\nfunction processProps(instance) {\n  var props = void 0;\n  if (isLegacy && (props = instance._props)) {\n    // 1.x\n    return Object.keys(props).map(function (key) {\n      var prop = props[key];\n      var options = prop.options;\n      return {\n        type: 'props',\n        key: prop.path,\n        value: instance[prop.path],\n        meta: {\n          type: options.type ? getPropType(options.type) : 'any',\n          required: !!options.required,\n          mode: propModes[prop.mode]\n        }\n      };\n    });\n  } else if (props = instance.$options.props) {\n    // 2.0\n    var propsData = [];\n    for (var key in props) {\n      var prop = props[key];\n      key = (0, _util.camelize)(key);\n      propsData.push({\n        type: 'props',\n        key: key,\n        value: instance[key],\n        meta: {\n          type: prop.type ? getPropType(prop.type) : 'any',\n          required: !!prop.required\n        }\n      });\n    }\n    return propsData;\n  } else {\n    return [];\n  }\n}\n\n/**\n * Convert prop type constructor to string.\n *\n * @param {Function} fn\n */\n\nvar fnTypeRE = /^(?:function|class) (\\w+)/;\nfunction getPropType(type) {\n  var match = type.toString().match(fnTypeRE);\n  return typeof type === 'function' ? match && match[1] || 'any' : 'any';\n}\n\n/**\n * Process state, filtering out props and \"clean\" the result\n * with a JSON dance. This removes functions which can cause\n * errors during structured clone used by window.postMessage.\n *\n * @param {Vue} instance\n * @return {Array}\n */\n\nfunction processState(instance) {\n  var props = isLegacy ? instance._props : instance.$options.props;\n  var getters = instance.$options.vuex && instance.$options.vuex.getters;\n  return Object.keys(instance._data).filter(function (key) {\n    return !(props && key in props) && !(getters && key in getters);\n  }).map(function (key) {\n    return {\n      key: key,\n      value: instance._data[key]\n    };\n  });\n}\n\n/**\n * Process the computed properties of an instance.\n *\n * @param {Vue} instance\n * @return {Array}\n */\n\nfunction processComputed(instance) {\n  var computed = [];\n  var defs = instance.$options.computed || {};\n  // use for...in here because if 'computed' is not defined\n  // on component, computed properties will be placed in prototype\n  // and Object.keys does not include\n  // properties from object's prototype\n  for (var key in defs) {\n    var def = defs[key];\n    var type = typeof def === 'function' && def.vuex ? 'vuex bindings' : 'computed';\n    // use try ... catch here because some computed properties may\n    // throw error during its evaluation\n    var computedProp = null;\n    try {\n      computedProp = {\n        type: type,\n        key: key,\n        value: instance[key]\n      };\n    } catch (e) {\n      computedProp = {\n        type: type,\n        key: key,\n        value: '(error during evaluation)'\n      };\n    }\n\n    computed.push(computedProp);\n  }\n\n  return computed;\n}\n\n/**\n * Process possible vue-router $route context\n *\n * @param {Vue} instance\n * @return {Array}\n */\n\nfunction processRouteContext(instance) {\n  var route = instance.$route;\n  if (route) {\n    var _path = route.path,\n        query = route.query,\n        params = route.params;\n\n    var value = { path: _path, query: query, params: params };\n    if (route.fullPath) value.fullPath = route.fullPath;\n    if (route.hash) value.hash = route.hash;\n    if (route.name) value.name = route.name;\n    if (route.meta) value.meta = route.meta;\n    return [{\n      key: '$route',\n      value: value\n    }];\n  } else {\n    return [];\n  }\n}\n\n/**\n * Process Vuex getters.\n *\n * @param {Vue} instance\n * @return {Array}\n */\n\nfunction processVuexGetters(instance) {\n  var getters = instance.$options.vuex && instance.$options.vuex.getters;\n  if (getters) {\n    return Object.keys(getters).map(function (key) {\n      return {\n        type: 'vuex getters',\n        key: key,\n        value: instance[key]\n      };\n    });\n  } else {\n    return [];\n  }\n}\n\n/**\n * Process Firebase bindings.\n *\n * @param {Vue} instance\n * @return {Array}\n */\n\nfunction processFirebaseBindings(instance) {\n  var refs = instance.$firebaseRefs;\n  if (refs) {\n    return Object.keys(refs).map(function (key) {\n      return {\n        type: 'firebase bindings',\n        key: key,\n        value: instance[key]\n      };\n    });\n  } else {\n    return [];\n  }\n}\n\n/**\n * Process vue-rx observable bindings.\n *\n * @param {Vue} instance\n * @return {Array}\n */\n\nfunction processObservables(instance) {\n  var obs = instance.$observables;\n  if (obs) {\n    return Object.keys(obs).map(function (key) {\n      return {\n        type: 'observables',\n        key: key,\n        value: instance[key]\n      };\n    });\n  } else {\n    return [];\n  }\n}\n\n/**\n * Sroll a node into view.\n *\n * @param {Vue} instance\n */\n\nfunction scrollIntoView(instance) {\n  var rect = (0, _highlighter.getInstanceRect)(instance);\n  if (rect) {\n    window.scrollBy(0, rect.top);\n  }\n}\n\n/**\n * Binds given instance in console as $vm0.\n * For compatibility reasons it also binds it as $vm.\n *\n * @param {Vue} instance\n */\n\nfunction bindToConsole(instance) {\n  var id = instance.__VUE_DEVTOOLS_UID__;\n  var index = consoleBoundInstances.indexOf(id);\n  if (index > -1) {\n    consoleBoundInstances.splice(index, 1);\n  } else {\n    consoleBoundInstances.pop();\n  }\n  consoleBoundInstances.unshift(id);\n  for (var i = 0; i < 5; i++) {\n    window['$vm' + i] = instanceMap.get(consoleBoundInstances[i]);\n  }\n  window.$vm = instance;\n}\n\n/**\n * Returns a devtools unique id for instance.\n * @param {Vue} instance\n */\nfunction getUniqueId(instance) {\n  var rootVueId = instance.$root.__VUE_DEVTOOLS_ROOT_UID__;\n  return rootVueId + ':' + instance._uid;\n}\n\n}).call(this,require('_process'))\n},{\"../util\":21,\"./events\":16,\"./highlighter\":17,\"./vuex\":20,\"_process\":15,\"path\":14}],20:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initVuexBackend = initVuexBackend;\n\nvar _util = require('src/util');\n\nfunction initVuexBackend(hook, bridge) {\n  var store = hook.store;\n  var recording = true;\n\n  var getSnapshot = function getSnapshot() {\n    return (0, _util.stringify)({\n      state: store.state,\n      getters: store.getters\n    });\n  };\n\n  bridge.send('vuex:init', getSnapshot());\n\n  // deal with multiple backend injections\n  hook.off('vuex:mutation');\n\n  // application -> devtool\n  hook.on('vuex:mutation', function (mutation) {\n    if (!recording) return;\n    bridge.send('vuex:mutation', {\n      mutation: {\n        type: mutation.type,\n        payload: (0, _util.stringify)(mutation.payload)\n      },\n      timestamp: Date.now(),\n      snapshot: getSnapshot()\n    });\n  });\n\n  // devtool -> application\n  bridge.on('vuex:travel-to-state', function (state) {\n    hook.emit('vuex:travel-to-state', state);\n  });\n\n  bridge.on('vuex:import-state', function (state) {\n    hook.emit('vuex:travel-to-state', state);\n    bridge.send('vuex:init', getSnapshot());\n  });\n\n  bridge.on('vuex:toggle-recording', function (enabled) {\n    recording = enabled;\n  });\n}\n\n},{\"src/util\":21}],21:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NAN = exports.INFINITY = exports.UNDEFINED = exports.camelize = exports.classify = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.inDoc = inDoc;\nexports.stringify = stringify;\nexports.parse = parse;\nexports.isPlainObject = isPlainObject;\nexports.searchDeepInObject = searchDeepInObject;\nexports.sortByKey = sortByKey;\n\nvar _circularJsonEs = require('circular-json-es6');\n\nvar _circularJsonEs2 = _interopRequireDefault(_circularJsonEs);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction cached(fn) {\n  var cache = Object.create(null);\n  return function cachedFn(str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\n\nvar classifyRE = /(?:^|[-_/])(\\w)/g;\nvar classify = exports.classify = cached(function (str) {\n  return str.replace(classifyRE, toUpper);\n});\n\nvar camelizeRE = /-(\\w)/g;\nvar camelize = exports.camelize = cached(function (str) {\n  return str.replace(camelizeRE, toUpper);\n});\n\nfunction toUpper(_, c) {\n  return c ? c.toUpperCase() : '';\n}\n\nfunction inDoc(node) {\n  if (!node) return false;\n  var doc = node.ownerDocument.documentElement;\n  var parent = node.parentNode;\n  return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));\n}\n\n/**\n * Stringify/parse data using CircularJSON.\n */\n\nvar UNDEFINED = exports.UNDEFINED = '__vue_devtool_undefined__';\nvar INFINITY = exports.INFINITY = '__vue_devtool_infinity__';\nvar NAN = exports.NAN = '__vue_devtool_nan__';\n\nfunction stringify(data) {\n  return _circularJsonEs2.default.stringify(data, replacer);\n}\n\nfunction replacer(key, val) {\n  if (val === undefined) {\n    return UNDEFINED;\n  } else if (val === Infinity) {\n    return INFINITY;\n  } else if (Number.isNaN(val)) {\n    return NAN;\n  } else if (val instanceof RegExp) {\n    // special handling of native type\n    return '[native RegExp ' + val.toString() + ']';\n  } else {\n    return sanitize(val);\n  }\n}\n\nfunction parse(data, revive) {\n  return revive ? _circularJsonEs2.default.parse(data, reviver) : _circularJsonEs2.default.parse(data);\n}\n\nfunction reviver(key, val) {\n  if (val === UNDEFINED) {\n    return undefined;\n  } else if (val === INFINITY) {\n    return Infinity;\n  } else if (val === NAN) {\n    return NaN;\n  } else {\n    return val;\n  }\n}\n\n/**\n * Sanitize data to be posted to the other side.\n * Since the message posted is sent with structured clone,\n * we need to filter out any types that might cause an error.\n *\n * @param {*} data\n * @return {*}\n */\n\nfunction sanitize(data) {\n  if (!isPrimitive(data) && !Array.isArray(data) && !isPlainObject(data)) {\n    // handle types that will probably cause issues in\n    // the structured clone\n    return Object.prototype.toString.call(data);\n  } else {\n    return data;\n  }\n}\n\nfunction isPlainObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n\nfunction isPrimitive(data) {\n  if (data == null) {\n    return true;\n  }\n  var type = typeof data === 'undefined' ? 'undefined' : _typeof(data);\n  return type === 'string' || type === 'number' || type === 'boolean';\n}\n\nfunction searchDeepInObject(obj, searchTerm) {\n  var match = false;\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = obj[key];\n    if (compare(key, searchTerm) || compare(value, searchTerm)) {\n      match = true;\n      break;\n    }\n    if (isPlainObject(value)) {\n      match = searchDeepInObject(value, searchTerm);\n      if (match) {\n        break;\n      }\n    }\n  }\n  return match;\n}\n\nfunction compare(mixedValue, stringValue) {\n  if (Array.isArray(mixedValue) && searchInArray(mixedValue, stringValue.toLowerCase())) {\n    return true;\n  }\n  if (('' + mixedValue).toLowerCase().indexOf(stringValue.toLowerCase()) !== -1) {\n    return true;\n  }\n  return false;\n}\n\nfunction searchInArray(arr, searchTerm) {\n  var found = false;\n  for (var i = 0; i < arr.length; i++) {\n    if (('' + arr[i]).toLowerCase().indexOf(searchTerm) !== -1) {\n      found = true;\n      break;\n    }\n  }\n  return found;\n}\n\nfunction sortByKey(state) {\n  return state && state.slice().sort(function (a, b) {\n    if (a.key < b.key) return -1;\n    if (a.key > b.key) return 1;\n    return 0;\n  });\n}\n\n},{\"circular-json-es6\":1}],22:[function(require,module,exports){\n'use strict';\n\nvar _hook = require('src/backend/hook');\n\nvar _kukerEmitters = require('kuker-emitters');\n\nvar MAX_MESSAGES_TO_CACHE = 50;\nvar HOOK_KEY = '__VUE_DEVTOOLS_GLOBAL_HOOK__';\nvar KUKER_HOOK_KEY = '__KUKER_VUE_HOOK__';\nvar detectAttempts = 7;\n\nvar detect = function detect(callback) {\n  detectAttempts -= 1;\n\n  if (window[HOOK_KEY] && !!window[HOOK_KEY].Vue) {\n    callback(null, window[HOOK_KEY]);\n  } else {\n    if (detectAttempts === 0) {\n      callback('Can not detect Vue on the page!');\n      return;\n    }\n    setTimeout(function () {\n      return detect(callback);\n    }, 1000);\n  }\n};\n\n(0, _hook.installHook)(window);\ndetect(function (error) {\n  if (error) return;\n\n  var listeners = [];\n  var bridgeListeners = {};\n\n  var _require = require('src/backend/index'),\n      initBackend = _require.initBackend,\n      getInstanceDetails = _require.getInstanceDetails;\n\n  var messages = [];\n  var defaultInstanceCharacteristics = { data: {}, computed: {}, props: {} };\n\n  window[KUKER_HOOK_KEY] = {\n    listen: function listen(callback) {\n      listeners.push(callback);\n      messages.forEach(function (_ref) {\n        var type = _ref.type,\n            payload = _ref.payload;\n        return callback(type, payload);\n      });\n    }\n  };\n\n  function populateVueTreeWithInstanceDetails(tree) {\n    return function process(node) {\n      if (node && node.id) {\n        var _getInstanceDetails = getInstanceDetails(node.id),\n            name = _getInstanceDetails.name,\n            state = _getInstanceDetails.state;\n\n        var _ref2 = state && Array.isArray(state) ? state.reduce(function (result, item) {\n          if (item.type === 'computed') {\n            result.computed[item.key] = item.value;\n          } else if (item.type === 'props') {\n            result.props[item.key] = item.value;\n          } else {\n            result.data[item.key] = item.value;\n          }\n          return result;\n        }, defaultInstanceCharacteristics) : defaultInstanceCharacteristics,\n            data = _ref2.data,\n            computed = _ref2.computed,\n            props = _ref2.props;\n\n        node = Object.assign(node, name && { name: name }, { data: (0, _kukerEmitters.sanitize)(data), computed: (0, _kukerEmitters.sanitize)(computed), props: (0, _kukerEmitters.sanitize)(props) });\n      }\n      if (node.children && node.children.length > 0) {\n        node.children = node.children.map(process);\n      }\n      return node;\n    }({\n      name: 'Vue',\n      state: {},\n      children: tree.instances || []\n    });\n  }\n\n  initBackend({\n    on: function on(type, callback) {\n      // we are currently not using these listeners but who knows ...\n      if (!bridgeListeners[type]) bridgeListeners[type] = [];\n      bridgeListeners[type].push(callback);\n    },\n    send: function send(type, payload) {\n      if (messages.length > MAX_MESSAGES_TO_CACHE) messages.shift();\n      if (type === 'flush') {\n        try {\n          payload = populateVueTreeWithInstanceDetails(JSON.parse(payload));\n        } catch (error) {\n          console.error('Vue tree can not be deserialized to json.');\n          payload = {};\n        }\n      }\n      messages.push({ type: type, payload: payload });\n      listeners.forEach(function (l) {\n        return l(type, payload);\n      });\n    },\n    log: function log() {}\n  });\n});\n\n},{\"kuker-emitters\":13,\"src/backend/hook\":18,\"src/backend/index\":19}]},{},[22]);\n";

var script = document.createElement('script');

script.textContent = vueDevtools.toString();
document.documentElement.appendChild(script);
script.parentNode.removeChild(script);

},{}]},{},[1]);
