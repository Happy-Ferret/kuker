(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

/* eslint-disable no-undef, vars-on-top */


var reactDevToolsConnector = "(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.reactDevToolsConnector = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (process){\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar validateFormat = function validateFormat(format) {};\n\nif (process.env.NODE_ENV !== 'production') {\n  validateFormat = function validateFormat(format) {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  };\n}\n\nfunction invariant(condition, format, a, b, c, d, e, f) {\n  validateFormat(format);\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(format.replace(/%s/g, function () {\n        return args[argIndex++];\n      }));\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n}\n\nmodule.exports = invariant;\n}).call(this,require('_process'))\n},{\"_process\":2}],2:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],3:[function(require,module,exports){\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';\n\n// Copied from React repo.\n\nmodule.exports = {\n  IndeterminateComponent: 0, // Before we know whether it is functional or class\n  FunctionalComponent: 1,\n  ClassComponent: 2,\n  HostRoot: 3, // Root of a host tree. Could be nested inside another node.\n  HostPortal: 4, // A subtree. Could be an entry point to a different renderer.\n  HostComponent: 5,\n  HostText: 6,\n  CoroutineComponent: 7,\n  CoroutineHandlerPhase: 8,\n  YieldComponent: 9,\n  Fragment: 10\n};\n\n},{}],4:[function(require,module,exports){\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';\n\nvar getData = require('./getData');\nvar getData012 = require('./getData012');\nvar attachRendererFiber = require('./attachRendererFiber');\n\n/**\n * This takes care of patching the renderer to emit events on the global\n * `Hook`. The returned object has a `.cleanup` method to un-patch everything.\n */\nfunction attachRenderer(hook, rid, renderer) {\n  var rootNodeIDMap = new Map();\n  var extras = {};\n  // Before 0.13 there was no Reconciler, so we patch Component.Mixin\n  var isPre013 = !renderer.Reconciler;\n\n  // React Fiber\n  if (typeof renderer.findFiberByHostInstance === 'function') {\n    return attachRendererFiber(hook, rid, renderer);\n  }\n\n  // React Native\n  if (renderer.Mount.findNodeHandle && renderer.Mount.nativeTagToRootNodeID) {\n    extras.getNativeFromReactElement = function (component) {\n      return renderer.Mount.findNodeHandle(component);\n    };\n\n    extras.getReactElementFromNative = function (nativeTag) {\n      var id = renderer.Mount.nativeTagToRootNodeID(nativeTag);\n      return rootNodeIDMap.get(id);\n    };\n    // React DOM 15+\n  } else if (renderer.ComponentTree) {\n    extras.getNativeFromReactElement = function (component) {\n      return renderer.ComponentTree.getNodeFromInstance(component);\n    };\n\n    extras.getReactElementFromNative = function (node) {\n      return renderer.ComponentTree.getClosestInstanceFromNode(node);\n    };\n    // React DOM\n  } else if (renderer.Mount.getID && renderer.Mount.getNode) {\n    extras.getNativeFromReactElement = function (component) {\n      try {\n        return renderer.Mount.getNode(component._rootNodeID);\n      } catch (e) {\n        return undefined;\n      }\n    };\n\n    extras.getReactElementFromNative = function (node) {\n      var id = renderer.Mount.getID(node);\n      while (node && node.parentNode && !id) {\n        node = node.parentNode;\n        id = renderer.Mount.getID(node);\n      }\n      return rootNodeIDMap.get(id);\n    };\n  } else {\n    console.warn('Unknown react version (does not have getID), probably an unshimmed React Native');\n  }\n\n  var oldMethods;\n  var oldRenderComponent;\n  var oldRenderRoot;\n\n  // React DOM\n  if (renderer.Mount._renderNewRootComponent) {\n    oldRenderRoot = decorateResult(renderer.Mount, '_renderNewRootComponent', function (internalInstance) {\n      hook.emit('root', { renderer: rid, internalInstance: internalInstance });\n    });\n    // React Native\n  } else if (renderer.Mount.renderComponent) {\n    oldRenderComponent = decorateResult(renderer.Mount, 'renderComponent', function (internalInstance) {\n      hook.emit('root', { renderer: rid, internalInstance: internalInstance._reactInternalInstance });\n    });\n  }\n\n  if (renderer.Component) {\n    console.error('You are using a version of React with limited support in this version of the devtools.\\nPlease upgrade to use at least 0.13, or you can downgrade to use the old version of the devtools:\\ninstructions here https://github.com/facebook/react-devtools/tree/devtools-next#how-do-i-use-this-for-react--013');\n    // 0.11 - 0.12\n    // $FlowFixMe renderer.Component is not \"possibly undefined\"\n    oldMethods = decorateMany(renderer.Component.Mixin, {\n      mountComponent: function mountComponent() {\n        var _this = this;\n\n        rootNodeIDMap.set(this._rootNodeID, this);\n        // FIXME DOMComponent calls Component.Mixin, and sets up the\n        // `children` *after* that call, meaning we don't have access to the\n        // children at this point. Maybe we should find something else to shim\n        // (do we have access to DOMComponent here?) so that we don't have to\n        // setTimeout.\n        setTimeout(function () {\n          hook.emit('mount', { internalInstance: _this, data: getData012(_this), renderer: rid });\n        }, 0);\n      },\n      updateComponent: function updateComponent() {\n        var _this2 = this;\n\n        setTimeout(function () {\n          hook.emit('update', { internalInstance: _this2, data: getData012(_this2), renderer: rid });\n        }, 0);\n      },\n      unmountComponent: function unmountComponent() {\n        hook.emit('unmount', { internalInstance: this, renderer: rid });\n        rootNodeIDMap.delete(this._rootNodeID, this);\n      }\n    });\n  } else if (renderer.Reconciler) {\n    oldMethods = decorateMany(renderer.Reconciler, {\n      mountComponent: function mountComponent(internalInstance, rootID, transaction, context) {\n        var data = getData(internalInstance);\n        rootNodeIDMap.set(internalInstance._rootNodeID, internalInstance);\n        hook.emit('mount', { internalInstance: internalInstance, data: data, renderer: rid });\n      },\n      performUpdateIfNecessary: function performUpdateIfNecessary(internalInstance, nextChild, transaction, context) {\n        hook.emit('update', { internalInstance: internalInstance, data: getData(internalInstance), renderer: rid });\n      },\n      receiveComponent: function receiveComponent(internalInstance, nextChild, transaction, context) {\n        hook.emit('update', { internalInstance: internalInstance, data: getData(internalInstance), renderer: rid });\n      },\n      unmountComponent: function unmountComponent(internalInstance) {\n        hook.emit('unmount', { internalInstance: internalInstance, renderer: rid });\n        rootNodeIDMap.delete(internalInstance._rootNodeID, internalInstance);\n      }\n    });\n  }\n\n  extras.walkTree = function (visit, visitRoot) {\n    var onMount = function onMount(component, data) {\n      rootNodeIDMap.set(component._rootNodeID, component);\n      visit(component, data);\n    };\n    walkRoots(renderer.Mount._instancesByReactRootID || renderer.Mount._instancesByContainerID, onMount, visitRoot, isPre013);\n  };\n\n  extras.cleanup = function () {\n    if (oldMethods) {\n      if (renderer.Component) {\n        restoreMany(renderer.Component.Mixin, oldMethods);\n      } else {\n        restoreMany(renderer.Reconciler, oldMethods);\n      }\n    }\n    if (oldRenderRoot) {\n      renderer.Mount._renderNewRootComponent = oldRenderRoot;\n    }\n    if (oldRenderComponent) {\n      renderer.Mount.renderComponent = oldRenderComponent;\n    }\n    oldMethods = null;\n    oldRenderRoot = null;\n    oldRenderComponent = null;\n  };\n\n  return extras;\n}\n\nfunction walkRoots(roots, onMount, onRoot, isPre013) {\n  for (var name in roots) {\n    walkNode(roots[name], onMount, isPre013);\n    onRoot(roots[name]);\n  }\n}\n\nfunction walkNode(internalInstance, onMount, isPre013) {\n  var data = isPre013 ? getData012(internalInstance) : getData(internalInstance);\n  if (data.children && Array.isArray(data.children)) {\n    data.children.forEach(function (child) {\n      return walkNode(child, onMount, isPre013);\n    });\n  }\n  onMount(internalInstance, data);\n}\n\nfunction decorateResult(obj, attr, fn) {\n  var old = obj[attr];\n  obj[attr] = function (instance) {\n    var res = old.apply(this, arguments);\n    fn(res);\n    return res;\n  };\n  return old;\n}\n\nfunction decorate(obj, attr, fn) {\n  var old = obj[attr];\n  obj[attr] = function (instance) {\n    var res = old.apply(this, arguments);\n    fn.apply(this, arguments);\n    return res;\n  };\n  return old;\n}\n\nfunction decorateMany(source, fns) {\n  var olds = {};\n  for (var name in fns) {\n    olds[name] = decorate(source, name, fns[name]);\n  }\n  return olds;\n}\n\nfunction restoreMany(source, olds) {\n  for (var name in olds) {\n    source[name] = olds[name];\n  }\n}\n\nmodule.exports = attachRenderer;\n\n},{\"./attachRendererFiber\":5,\"./getData\":8,\"./getData012\":9}],5:[function(require,module,exports){\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';\n\nvar getDataFiber = require('./getDataFiber');\n\nvar _require = require('./ReactTypeOfWork'),\n    ClassComponent = _require.ClassComponent,\n    HostRoot = _require.HostRoot;\n\n// Inlined from ReactTypeOfSideEffect\n\n\nvar PerformedWork = 1;\n\nfunction attachRendererFiber(hook, rid, renderer) {\n  // This is a slightly annoying indirection.\n  // It is currently necessary because DevTools wants\n  // to use unique objects as keys for instances.\n  // However fibers have two versions.\n  // We use this set to remember first encountered fiber for\n  // each conceptual instance.\n  var opaqueNodes = new Set();\n  function getOpaqueNode(fiber) {\n    if (opaqueNodes.has(fiber)) {\n      return fiber;\n    }\n    var alternate = fiber.alternate;\n\n    if (alternate != null && opaqueNodes.has(alternate)) {\n      return alternate;\n    }\n    opaqueNodes.add(fiber);\n    return fiber;\n  }\n\n  function hasDataChanged(prevFiber, nextFiber) {\n    if (prevFiber.tag === ClassComponent) {\n      // Skip if the class performed no work (shouldComponentUpdate bailout).\n      // eslint-disable-next-line no-bitwise\n      if ((nextFiber.effectTag & PerformedWork) !== PerformedWork) {\n        return false;\n      }\n\n      // Only classes have context.\n      if (prevFiber.stateNode.context !== nextFiber.stateNode.context) {\n        return true;\n      }\n      // Force updating won't update state or props.\n      if (nextFiber.updateQueue != null && nextFiber.updateQueue.hasForceUpdate) {\n        return true;\n      }\n    }\n    // Compare the fields that would result in observable changes in DevTools.\n    // We don't compare type, tag, index, and key, because these are known to match.\n    return prevFiber.memoizedProps !== nextFiber.memoizedProps || prevFiber.memoizedState !== nextFiber.memoizedState || prevFiber.ref !== nextFiber.ref || prevFiber._debugSource !== nextFiber._debugSource;\n  }\n\n  var pendingEvents = [];\n\n  function flushPendingEvents() {\n    var events = pendingEvents;\n    pendingEvents = [];\n    for (var i = 0; i < events.length; i++) {\n      var event = events[i];\n      hook.emit(event.type, event);\n    }\n  }\n\n  function enqueueMount(fiber) {\n    pendingEvents.push({\n      internalInstance: getOpaqueNode(fiber),\n      data: getDataFiber(fiber, getOpaqueNode),\n      renderer: rid,\n      type: 'mount'\n    });\n\n    var isRoot = fiber.tag === HostRoot;\n    if (isRoot) {\n      pendingEvents.push({\n        internalInstance: getOpaqueNode(fiber),\n        renderer: rid,\n        type: 'root'\n      });\n    }\n  }\n\n  function enqueueUpdateIfNecessary(fiber, hasChildOrderChanged) {\n    if (!hasChildOrderChanged && !hasDataChanged(fiber.alternate, fiber)) {\n      return;\n    }\n    pendingEvents.push({\n      internalInstance: getOpaqueNode(fiber),\n      data: getDataFiber(fiber, getOpaqueNode),\n      renderer: rid,\n      type: 'update'\n    });\n  }\n\n  function enqueueUnmount(fiber) {\n    var isRoot = fiber.tag === HostRoot;\n    var opaqueNode = getOpaqueNode(fiber);\n    var event = {\n      internalInstance: opaqueNode,\n      renderer: rid,\n      type: 'unmount'\n    };\n    if (isRoot) {\n      pendingEvents.push(event);\n    } else {\n      // Non-root fibers are deleted during the commit phase.\n      // They are deleted in the child-first order. However\n      // DevTools currently expects deletions to be parent-first.\n      // This is why we unshift deletions rather than push them.\n      pendingEvents.unshift(event);\n    }\n    opaqueNodes.delete(opaqueNode);\n  }\n\n  function mountFiber(fiber) {\n    // Depth-first.\n    // Logs mounting of children first, parents later.\n    var node = fiber;\n    outer: while (true) {\n      if (node.child) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n      enqueueMount(node);\n      if (node == fiber) {\n        return;\n      }\n      if (node.sibling) {\n        node.sibling.return = node.return;\n        node = node.sibling;\n        continue;\n      }\n      while (node.return) {\n        node = node.return;\n        enqueueMount(node);\n        if (node == fiber) {\n          return;\n        }\n        if (node.sibling) {\n          node.sibling.return = node.return;\n          node = node.sibling;\n          continue outer;\n        }\n      }\n      return;\n    }\n  }\n\n  function updateFiber(nextFiber, prevFiber) {\n    var hasChildOrderChanged = false;\n    if (nextFiber.child !== prevFiber.child) {\n      // If the first child is different, we need to traverse them.\n      // Each next child will be either a new child (mount) or an alternate (update).\n      var nextChild = nextFiber.child;\n      var prevChildAtSameIndex = prevFiber.child;\n      while (nextChild) {\n        // We already know children will be referentially different because\n        // they are either new mounts or alternates of previous children.\n        // Schedule updates and mounts depending on whether alternates exist.\n        // We don't track deletions here because they are reported separately.\n        if (nextChild.alternate) {\n          var prevChild = nextChild.alternate;\n          updateFiber(nextChild, prevChild);\n          // However we also keep track if the order of the children matches\n          // the previous order. They are always different referentially, but\n          // if the instances line up conceptually we'll want to know that.\n          if (!hasChildOrderChanged && prevChild !== prevChildAtSameIndex) {\n            hasChildOrderChanged = true;\n          }\n        } else {\n          mountFiber(nextChild);\n          if (!hasChildOrderChanged) {\n            hasChildOrderChanged = true;\n          }\n        }\n        // Try the next child.\n        nextChild = nextChild.sibling;\n        // Advance the pointer in the previous list so that we can\n        // keep comparing if they line up.\n        if (!hasChildOrderChanged && prevChildAtSameIndex != null) {\n          prevChildAtSameIndex = prevChildAtSameIndex.sibling;\n        }\n      }\n      // If we have no more children, but used to, they don't line up.\n      if (!hasChildOrderChanged && prevChildAtSameIndex != null) {\n        hasChildOrderChanged = true;\n      }\n    }\n    enqueueUpdateIfNecessary(nextFiber, hasChildOrderChanged);\n  }\n\n  function walkTree() {\n    hook.getFiberRoots(rid).forEach(function (root) {\n      // Hydrate all the roots for the first time.\n      mountFiber(root.current);\n    });\n    flushPendingEvents();\n  }\n\n  function cleanup() {\n    // We don't patch any methods so there is no cleanup.\n  }\n\n  function handleCommitFiberUnmount(fiber) {\n    // This is not recursive.\n    // We can't traverse fibers after unmounting so instead\n    // we rely on React telling us about each unmount.\n    // It will be flushed after the root is committed.\n    enqueueUnmount(fiber);\n  }\n\n  function handleCommitFiberRoot(root) {\n    var current = root.current;\n    var alternate = current.alternate;\n    if (alternate) {\n      // TODO: relying on this seems a bit fishy.\n      var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null;\n      var isMounted = current.memoizedState != null && current.memoizedState.element != null;\n      if (!wasMounted && isMounted) {\n        // Mount a new root.\n        mountFiber(current);\n      } else if (wasMounted && isMounted) {\n        // Update an existing root.\n        updateFiber(current, alternate);\n      } else if (wasMounted && !isMounted) {\n        // Unmount an existing root.\n        enqueueUnmount(current);\n      }\n    } else {\n      // Mount a new root.\n      mountFiber(current);\n    }\n    // We're done here.\n    flushPendingEvents();\n  }\n\n  // The naming is confusing.\n  // They deal with opaque nodes (fibers), not elements.\n  function getNativeFromReactElement(fiber) {\n    try {\n      var opaqueNode = fiber;\n      var hostInstance = renderer.findHostInstanceByFiber(opaqueNode);\n      return hostInstance;\n    } catch (err) {\n      // The fiber might have unmounted by now.\n      return null;\n    }\n  }\n  function getReactElementFromNative(hostInstance) {\n    var fiber = renderer.findFiberByHostInstance(hostInstance);\n    if (fiber != null) {\n      // TODO: type fibers.\n      var opaqueNode = getOpaqueNode(fiber);\n      return opaqueNode;\n    }\n    return null;\n  }\n  return {\n    getNativeFromReactElement: getNativeFromReactElement,\n    getReactElementFromNative: getReactElementFromNative,\n    handleCommitFiberRoot: handleCommitFiberRoot,\n    handleCommitFiberUnmount: handleCommitFiberUnmount,\n    cleanup: cleanup,\n    walkTree: walkTree\n  };\n}\n\nmodule.exports = attachRendererFiber;\n\n},{\"./ReactTypeOfWork\":3,\"./getDataFiber\":10}],6:[function(require,module,exports){\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n *\n * This is the chrome devtools\n *\n * 1. Devtools sets the __REACT_DEVTOOLS_GLOBAL_HOOK__ global.\n * 2. React (if present) calls .inject() with the internal renderer\n * 3. Devtools sees the renderer, and then adds this backend, along with the Agent\n *    and whatever else is needed.\n * 4. The agent then calls `.emit('react-devtools', agent)`\n *\n * Now things are hooked up.\n *\n * When devtools closes, it calls `cleanup()` to remove the listeners\n * and any overhead caused by the backend.\n */\n'use strict';\n\nvar attachRenderer = require('./attachRenderer');\n\nmodule.exports = function setupBackend(hook) {\n  var oldReact = window.React && window.React.__internals;\n  if (oldReact && Object.keys(hook._renderers).length === 0) {\n    hook.inject(oldReact);\n  }\n\n  for (var rid in hook._renderers) {\n    hook.helpers[rid] = attachRenderer(hook, rid, hook._renderers[rid]);\n    hook.emit('renderer-attached', { id: rid, renderer: hook._renderers[rid], helpers: hook.helpers[rid] });\n  }\n\n  hook.on('renderer', function (_ref) {\n    var id = _ref.id,\n        renderer = _ref.renderer;\n\n    hook.helpers[id] = attachRenderer(hook, id, renderer);\n    hook.emit('renderer-attached', { id: id, renderer: renderer, helpers: hook.helpers[id] });\n  });\n\n  var shutdown = function shutdown() {\n    for (var id in hook.helpers) {\n      hook.helpers[id].cleanup();\n    }\n    hook.off('shutdown', shutdown);\n  };\n  hook.on('shutdown', shutdown);\n\n  return true;\n};\n\n},{\"./attachRenderer\":4}],7:[function(require,module,exports){\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction copyWithSetImpl(obj, path, idx, value) {\n  if (idx >= path.length) {\n    return value;\n  }\n  var key = path[idx];\n  var updated = Array.isArray(obj) ? obj.slice() : _extends({}, obj);\n  // $FlowFixMe number or string is fine here\n  updated[key] = copyWithSetImpl(obj[key], path, idx + 1, value);\n  return updated;\n}\n\nfunction copyWithSet(obj, path, value) {\n  return copyWithSetImpl(obj, path, 0, value);\n}\n\nmodule.exports = copyWithSet;\n\n},{}],8:[function(require,module,exports){\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar copyWithSet = require('./copyWithSet');\nvar getDisplayName = require('./getDisplayName');\nvar traverseAllChildrenImpl = require('./traverseAllChildrenImpl');\n\n/**\n * Convert a react internal instance to a sanitized data object.\n */\nfunction getData(internalInstance) {\n  var children = null;\n  var props = null;\n  var state = null;\n  var context = null;\n  var updater = null;\n  var name = null;\n  var type = null;\n  var key = null;\n  var ref = null;\n  var source = null;\n  var text = null;\n  var publicInstance = null;\n  var nodeType = 'Native';\n  // If the parent is a native node without rendered children, but with\n  // multiple string children, then the `element` that gets passed in here is\n  // a plain value -- a string or number.\n  if ((typeof internalInstance === 'undefined' ? 'undefined' : _typeof(internalInstance)) !== 'object') {\n    nodeType = 'Text';\n    text = internalInstance + '';\n  } else if (internalInstance._currentElement === null || internalInstance._currentElement === false) {\n    nodeType = 'Empty';\n  } else if (internalInstance._renderedComponent) {\n    nodeType = 'NativeWrapper';\n    children = [internalInstance._renderedComponent];\n    props = internalInstance._instance.props;\n    state = internalInstance._instance.state;\n    context = internalInstance._instance.context;\n    if (context && Object.keys(context).length === 0) {\n      context = null;\n    }\n  } else if (internalInstance._renderedChildren) {\n    children = childrenList(internalInstance._renderedChildren);\n  } else if (internalInstance._currentElement && internalInstance._currentElement.props) {\n    // This is a native node without rendered children -- meaning the children\n    // prop is the unfiltered list of children.\n    // This may include 'null' or even other invalid values, so we need to\n    // filter it the same way that ReactDOM does.\n    // Instead of pulling in the whole React library, we just copied over the\n    // 'traverseAllChildrenImpl' method.\n    // https://github.com/facebook/react/blob/240b84ed8e1db715d759afaae85033718a0b24e1/src/isomorphic/children/ReactChildren.js#L112-L158\n    var unfilteredChildren = internalInstance._currentElement.props.children;\n    var filteredChildren = [];\n    traverseAllChildrenImpl(unfilteredChildren, '', // nameSoFar\n    function (_traverseContext, child) {\n      var childType = typeof child === 'undefined' ? 'undefined' : _typeof(child);\n      if (childType === 'string' || childType === 'number') {\n        filteredChildren.push(child);\n      }\n    }\n    // traverseContext\n    );\n    if (filteredChildren.length <= 1) {\n      // children must be an array of nodes or a string or undefined\n      // can't be an empty array\n      children = filteredChildren.length ? String(filteredChildren[0]) : undefined;\n    } else {\n      children = filteredChildren;\n    }\n  }\n\n  if (!props && internalInstance._currentElement && internalInstance._currentElement.props) {\n    props = internalInstance._currentElement.props;\n  }\n\n  // != used deliberately here to catch undefined and null\n  if (internalInstance._currentElement != null) {\n    type = internalInstance._currentElement.type;\n    if (internalInstance._currentElement.key) {\n      key = String(internalInstance._currentElement.key);\n    }\n    source = internalInstance._currentElement._source;\n    ref = internalInstance._currentElement.ref;\n    if (typeof type === 'string') {\n      name = type;\n      if (internalInstance._nativeNode != null) {\n        publicInstance = internalInstance._nativeNode;\n      }\n      if (internalInstance._hostNode != null) {\n        publicInstance = internalInstance._hostNode;\n      }\n    } else if (typeof type === 'function') {\n      nodeType = 'Composite';\n      name = getDisplayName(type);\n      // 0.14 top-level wrapper\n      // TODO(jared): The backend should just act as if these don't exist.\n      if (internalInstance._renderedComponent && (internalInstance._currentElement.props === internalInstance._renderedComponent._currentElement || internalInstance._currentElement.type.isReactTopLevelWrapper)) {\n        nodeType = 'Wrapper';\n      }\n      if (name === null) {\n        name = 'No display name';\n      }\n    } else if (typeof internalInstance._stringText === 'string') {\n      nodeType = 'Text';\n      text = internalInstance._stringText;\n    } else {\n      name = getDisplayName(type);\n    }\n  }\n\n  if (internalInstance._instance) {\n    var inst = internalInstance._instance;\n\n    // A forceUpdate for stateless (functional) components.\n    var forceUpdate = inst.forceUpdate || inst.updater && inst.updater.enqueueForceUpdate && function (cb) {\n      inst.updater.enqueueForceUpdate(this, cb, 'forceUpdate');\n    };\n    updater = {\n      setState: inst.setState && inst.setState.bind(inst),\n      forceUpdate: forceUpdate && forceUpdate.bind(inst),\n      setInProps: forceUpdate && setInProps.bind(null, internalInstance, forceUpdate),\n      setInState: inst.forceUpdate && setInState.bind(null, inst),\n      setInContext: forceUpdate && setInContext.bind(null, inst, forceUpdate)\n    };\n    if (typeof type === 'function') {\n      publicInstance = inst;\n    }\n\n    // TODO: React ART currently falls in this bucket, but this doesn't\n    // actually make sense and we should clean this up after stabilizing our\n    // API for backends\n    if (inst._renderedChildren) {\n      children = childrenList(inst._renderedChildren);\n    }\n  }\n\n  if (typeof internalInstance.setNativeProps === 'function') {\n    // For editing styles in RN\n    updater = {\n      setNativeProps: function setNativeProps(nativeProps) {\n        internalInstance.setNativeProps(nativeProps);\n      }\n    };\n  }\n\n  return {\n    nodeType: nodeType,\n    type: type,\n    key: key,\n    ref: ref,\n    source: source,\n    name: name,\n    props: props,\n    state: state,\n    context: context,\n    children: children,\n    text: text,\n    updater: updater,\n    publicInstance: publicInstance\n  };\n}\n\nfunction setInProps(internalInst, forceUpdate, path, value) {\n  var element = internalInst._currentElement;\n  internalInst._currentElement = _extends({}, element, {\n    props: copyWithSet(element.props, path, value)\n  });\n  forceUpdate.call(internalInst._instance);\n}\n\nfunction setInState(inst, path, value) {\n  setIn(inst.state, path, value);\n  inst.forceUpdate();\n}\n\nfunction setInContext(inst, forceUpdate, path, value) {\n  setIn(inst.context, path, value);\n  forceUpdate.call(inst);\n}\n\nfunction setIn(obj, path, value) {\n  var last = path.pop();\n  var parent = path.reduce(function (obj_, attr) {\n    return obj_ ? obj_[attr] : null;\n  }, obj);\n  if (parent) {\n    parent[last] = value;\n  }\n}\n\nfunction childrenList(children) {\n  var res = [];\n  for (var name in children) {\n    res.push(children[name]);\n  }\n  return res;\n}\n\nmodule.exports = getData;\n\n},{\"./copyWithSet\":7,\"./getDisplayName\":11,\"./traverseAllChildrenImpl\":13}],9:[function(require,module,exports){\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';\n\nvar copyWithSet = require('./copyWithSet');\n\nfunction getData012(internalInstance) {\n  var children = null;\n  var props = internalInstance.props;\n  var state = internalInstance.state;\n  var context = internalInstance.context;\n  var updater = null;\n  var name = null;\n  var type = null;\n  var key = null;\n  var ref = null;\n  var text = null;\n  var publicInstance = null;\n  var nodeType = 'Native';\n  if (internalInstance._renderedComponent) {\n    nodeType = 'Wrapper';\n    children = [internalInstance._renderedComponent];\n    if (context && Object.keys(context).length === 0) {\n      context = null;\n    }\n  } else if (internalInstance._renderedChildren) {\n    name = internalInstance.constructor.displayName;\n    children = childrenList(internalInstance._renderedChildren);\n  } else if (typeof props.children === 'string') {\n    // string children\n    name = internalInstance.constructor.displayName;\n    children = props.children;\n    nodeType = 'Native';\n  }\n\n  if (!props && internalInstance._currentElement && internalInstance._currentElement.props) {\n    props = internalInstance._currentElement.props;\n  }\n\n  if (internalInstance._currentElement) {\n    type = internalInstance._currentElement.type;\n    if (internalInstance._currentElement.key) {\n      key = String(internalInstance._currentElement.key);\n    }\n    ref = internalInstance._currentElement.ref;\n    if (typeof type === 'string') {\n      name = type;\n    } else {\n      nodeType = 'Composite';\n      name = type.displayName;\n      if (!name) {\n        name = 'No display name';\n      }\n    }\n  }\n\n  if (!name) {\n    name = internalInstance.constructor.displayName || 'No display name';\n    nodeType = 'Composite';\n  }\n\n  if (typeof props === 'string') {\n    nodeType = 'Text';\n    text = props;\n    props = null;\n    name = null;\n  }\n\n  if (internalInstance.forceUpdate) {\n    updater = {\n      setState: internalInstance.setState.bind(internalInstance),\n      forceUpdate: internalInstance.forceUpdate.bind(internalInstance),\n      setInProps: internalInstance.forceUpdate && setInProps.bind(null, internalInstance),\n      setInState: internalInstance.forceUpdate && setInState.bind(null, internalInstance),\n      setInContext: internalInstance.forceUpdate && setInContext.bind(null, internalInstance)\n    };\n    publicInstance = internalInstance;\n  }\n\n  return {\n    nodeType: nodeType,\n    type: type,\n    key: key,\n    ref: ref,\n    source: null,\n    name: name,\n    props: props,\n    state: state,\n    context: context,\n    children: children,\n    text: text,\n    updater: updater,\n    publicInstance: publicInstance\n  };\n}\n\nfunction setInProps(inst, path, value) {\n  inst.props = copyWithSet(inst.props, path, value);\n  inst.forceUpdate();\n}\n\nfunction setInState(inst, path, value) {\n  setIn(inst.state, path, value);\n  inst.forceUpdate();\n}\n\nfunction setInContext(inst, path, value) {\n  setIn(inst.context, path, value);\n  inst.forceUpdate();\n}\n\nfunction setIn(obj, path, value) {\n  var last = path.pop();\n  var parent = path.reduce(function (obj_, attr) {\n    return obj_ ? obj_[attr] : null;\n  }, obj);\n  if (parent) {\n    parent[last] = value;\n  }\n}\n\nfunction childrenList(children) {\n  var res = [];\n  for (var name in children) {\n    res.push(children[name]);\n  }\n  return res;\n}\n\nmodule.exports = getData012;\n\n},{\"./copyWithSet\":7}],10:[function(require,module,exports){\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';\n\nvar copyWithSet = require('./copyWithSet');\nvar getDisplayName = require('./getDisplayName');\n\nvar _require = require('./ReactTypeOfWork'),\n    FunctionalComponent = _require.FunctionalComponent,\n    ClassComponent = _require.ClassComponent,\n    HostRoot = _require.HostRoot,\n    HostPortal = _require.HostPortal,\n    HostComponent = _require.HostComponent,\n    HostText = _require.HostText,\n    Fragment = _require.Fragment;\n\n// TODO: we might want to change the data structure\n// once we no longer suppport Stack versions of `getData`.\n\n\nfunction getDataFiber(fiber, getOpaqueNode) {\n  var type = fiber.type;\n  var key = fiber.key;\n  var ref = fiber.ref;\n  var source = fiber._debugSource;\n  var publicInstance = null;\n  var props = null;\n  var state = null;\n  var children = null;\n  var context = null;\n  var updater = null;\n  var nodeType = null;\n  var name = null;\n  var text = null;\n\n  switch (fiber.tag) {\n    case FunctionalComponent:\n    case ClassComponent:\n      nodeType = 'Composite';\n      name = getDisplayName(fiber.type);\n      publicInstance = fiber.stateNode;\n      props = fiber.memoizedProps;\n      state = fiber.memoizedState;\n      if (publicInstance != null) {\n        context = publicInstance.context;\n        if (context && Object.keys(context).length === 0) {\n          context = null;\n        }\n      }\n      var inst = publicInstance;\n      if (inst) {\n        updater = {\n          setState: inst.setState && inst.setState.bind(inst),\n          forceUpdate: inst.forceUpdate && inst.forceUpdate.bind(inst),\n          setInProps: inst.forceUpdate && setInProps.bind(null, fiber),\n          setInState: inst.forceUpdate && setInState.bind(null, inst),\n          setInContext: inst.forceUpdate && setInContext.bind(null, inst)\n        };\n      }\n      children = [];\n      break;\n    case HostRoot:\n      nodeType = 'Wrapper';\n      children = [];\n      break;\n    case HostPortal:\n      nodeType = 'Portal';\n      name = 'ReactPortal';\n      props = {\n        target: fiber.stateNode.containerInfo\n      };\n      children = [];\n      break;\n    case HostComponent:\n      nodeType = 'Native';\n      name = fiber.type;\n\n      // TODO (bvaughn) we plan to remove this prefix anyway.\n      // We can cut this special case out when it's gone.\n      name = name.replace('topsecret-', '');\n\n      publicInstance = fiber.stateNode;\n      props = fiber.memoizedProps;\n      if (typeof props.children === 'string' || typeof props.children === 'number') {\n        children = props.children.toString();\n      } else {\n        children = [];\n      }\n      if (typeof fiber.stateNode.setNativeProps === 'function') {\n        // For editing styles in RN\n        updater = {\n          setNativeProps: function setNativeProps(nativeProps) {\n            fiber.stateNode.setNativeProps(nativeProps);\n          }\n        };\n      }\n      break;\n    case HostText:\n      nodeType = 'Text';\n      text = fiber.memoizedProps;\n      break;\n    case Fragment:\n      nodeType = 'Wrapper';\n      children = [];\n      break;\n    default:\n      // Coroutines and yields\n      nodeType = 'Native';\n      props = fiber.memoizedProps;\n      name = 'TODO_NOT_IMPLEMENTED_YET';\n      children = [];\n      break;\n  }\n\n  if (Array.isArray(children)) {\n    var child = fiber.child;\n    while (child) {\n      children.push(getOpaqueNode(child));\n      child = child.sibling;\n    }\n  }\n\n  return {\n    nodeType: nodeType,\n    type: type,\n    key: key,\n    ref: ref,\n    source: source,\n    name: name,\n    props: props,\n    state: state,\n    context: context,\n    children: children,\n    text: text,\n    updater: updater,\n    publicInstance: publicInstance\n  };\n}\n\nfunction setInProps(fiber, path, value) {\n  var inst = fiber.stateNode;\n  fiber.pendingProps = copyWithSet(inst.props, path, value);\n  if (fiber.alternate) {\n    // We don't know which fiber is the current one because DevTools may bail out of getDataFiber() call,\n    // and so the data object may refer to another version of the fiber. Therefore we update pendingProps\n    // on both. I hope that this is safe.\n    fiber.alternate.pendingProps = fiber.pendingProps;\n  }\n  fiber.stateNode.forceUpdate();\n}\n\nfunction setInState(inst, path, value) {\n  setIn(inst.state, path, value);\n  inst.forceUpdate();\n}\n\nfunction setInContext(inst, path, value) {\n  setIn(inst.context, path, value);\n  inst.forceUpdate();\n}\n\nfunction setIn(obj, path, value) {\n  var last = path.pop();\n  var parent = path.reduce(function (obj_, attr) {\n    return obj_ ? obj_[attr] : null;\n  }, obj);\n  if (parent) {\n    parent[last] = value;\n  }\n}\n\nmodule.exports = getDataFiber;\n\n},{\"./ReactTypeOfWork\":3,\"./copyWithSet\":7,\"./getDisplayName\":11}],11:[function(require,module,exports){\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';\n\nvar FB_MODULE_RE = /^(.*) \\[from (.*)\\]$/;\nvar cachedDisplayNames = new WeakMap();\n\nfunction getDisplayName(type) {\n  if (cachedDisplayNames.has(type)) {\n    return cachedDisplayNames.get(type);\n  }\n\n  var displayName = void 0;\n\n  // The displayName property is not guaranteed to be a string.\n  // It's only safe to use for our purposes if it's a string.\n  // github.com/facebook/react-devtools/issues/803\n  if (typeof type.displayName === 'string') {\n    displayName = type.displayName;\n  }\n\n  if (!displayName) {\n    displayName = type.name || 'Unknown';\n  }\n\n  // Facebook-specific hack to turn \"Image [from Image.react]\" into just \"Image\".\n  // We need displayName with module name for error reports but it clutters the DevTools.\n  var match = displayName.match(FB_MODULE_RE);\n  if (match) {\n    var componentName = match[1];\n    var moduleName = match[2];\n    if (componentName && moduleName) {\n      if (moduleName === componentName || moduleName.startsWith(componentName + '.')) {\n        displayName = componentName;\n      }\n    }\n  }\n\n  cachedDisplayNames.set(type, displayName);\n  return displayName;\n}\n\nmodule.exports = getDisplayName;\n\n},{}],12:[function(require,module,exports){\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';\n\n/**\n * NOTE: This file cannot `require` any other modules. We `.toString()` the\n *       function in some places and inject the source into the page.\n */\nfunction installGlobalHook(window) {\n  if (window.__REACT_DEVTOOLS_GLOBAL_HOOK__) {\n    return;\n  }\n  function detectReactBuildType(renderer) {\n    try {\n      if (typeof renderer.version === 'string') {\n        // React DOM Fiber (16+)\n        if (renderer.bundleType > 0) {\n          // This is not a production build.\n          // We are currently only using 0 (PROD) and 1 (DEV)\n          // but might add 2 (PROFILE) in the future.\n          return 'development';\n        }\n\n        // React 16 uses flat bundles. If we report the bundle as production\n        // version, it means we also minified and envified it ourselves.\n        return 'production';\n        // Note: There is still a risk that the CommonJS entry point has not\n        // been envified or uglified. In this case the user would have *both*\n        // development and production bundle, but only the prod one would run.\n        // This would be really bad. We have a separate check for this because\n        // it happens *outside* of the renderer injection. See `checkDCE` below.\n      }\n      var toString = Function.prototype.toString;\n      if (renderer.Mount && renderer.Mount._renderNewRootComponent) {\n        // React DOM Stack\n        var renderRootCode = toString.call(renderer.Mount._renderNewRootComponent);\n        // Filter out bad results (if that is even possible):\n        if (renderRootCode.indexOf('function') !== 0) {\n          // Hope for the best if we're not sure.\n          return 'production';\n        }\n        // Check for React DOM Stack < 15.1.0 in development.\n        // If it contains \"storedMeasure\" call, it's wrapped in ReactPerf (DEV only).\n        // This would be true even if it's minified, as method name still matches.\n        if (renderRootCode.indexOf('storedMeasure') !== -1) {\n          return 'development';\n        }\n        // For other versions (and configurations) it's not so easy.\n        // Let's quickly exclude proper production builds.\n        // If it contains a warning message, it's either a DEV build,\n        // or an PROD build without proper dead code elimination.\n        if (renderRootCode.indexOf('should be a pure function') !== -1) {\n          // Now how do we tell a DEV build from a bad PROD build?\n          // If we see NODE_ENV, we're going to assume this is a dev build\n          // because most likely it is referring to an empty shim.\n          if (renderRootCode.indexOf('NODE_ENV') !== -1) {\n            return 'development';\n          }\n          // If we see \"development\", we're dealing with an envified DEV build\n          // (such as the official React DEV UMD).\n          if (renderRootCode.indexOf('development') !== -1) {\n            return 'development';\n          }\n          // I've seen process.env.NODE_ENV !== 'production' being smartly\n          // replaced by `true` in DEV by Webpack. I don't know how that\n          // works but we can safely guard against it because `true` was\n          // never used in the function source since it was written.\n          if (renderRootCode.indexOf('true') !== -1) {\n            return 'development';\n          }\n          // By now either it is a production build that has not been minified,\n          // or (worse) this is a minified development build using non-standard\n          // environment (e.g. \"staging\"). We're going to look at whether\n          // the function argument name is mangled:\n          if (\n          // 0.13 to 15\n          renderRootCode.indexOf('nextElement') !== -1 ||\n          // 0.12\n          renderRootCode.indexOf('nextComponent') !== -1) {\n            // We can't be certain whether this is a development build or not,\n            // but it is definitely unminified.\n            return 'unminified';\n          } else {\n            // This is likely a minified development build.\n            return 'development';\n          }\n        }\n        // By now we know that it's envified and dead code elimination worked,\n        // but what if it's still not minified? (Is this even possible?)\n        // Let's check matches for the first argument name.\n        if (\n        // 0.13 to 15\n        renderRootCode.indexOf('nextElement') !== -1 ||\n        // 0.12\n        renderRootCode.indexOf('nextComponent') !== -1) {\n          return 'unminified';\n        }\n        // Seems like we're using the production version.\n        // Now let's check if we're still on 0.14 or lower:\n        if (renderRootCode.indexOf('._registerComponent') !== -1) {\n          // TODO: we can remove the condition above once 16\n          // is older than a year. Since this branch only runs\n          // for Stack, we can flip it completely when Stack\n          // is old enough. The branch for Fiber is above,\n          // and it can check renderer.version directly.\n          return 'outdated';\n        }\n        // We're all good.\n        return 'production';\n      }\n    } catch (err) {\n      // Weird environments may exist.\n      // This code needs a higher fault tolerance\n      // because it runs even with closed DevTools.\n      // TODO: should we catch errors in all injected code, and not just this part?\n    }\n    return 'production';\n  }\n\n  var hasDetectedBadDCE = false;\n\n  var hook = {\n    // Shared between Stack and Fiber:\n    _renderers: {},\n    helpers: {},\n    checkDCE: function checkDCE(fn) {\n      // This runs for production versions of React.\n      // Needs to be super safe.\n      try {\n        var toString = Function.prototype.toString;\n        var code = toString.call(fn);\n        // This is a string embedded in the passed function under DEV-only\n        // condition. However the function executes only in PROD. Therefore,\n        // if we see it, dead code elimination did not work.\n        if (code.indexOf('^_^') > -1) {\n          // Remember to report during next injection.\n          hasDetectedBadDCE = true;\n          // Bonus: throw an exception hoping that it gets picked up by\n          // a reporting system. Not synchronously so that it doesn't break the\n          // calling code.\n          setTimeout(function () {\n            throw new Error('React is running in production mode, but dead code ' + 'elimination has not been applied. Read how to correctly ' + 'configure React for production: ' + 'https://fb.me/react-perf-use-the-production-build');\n          });\n        }\n      } catch (err) {}\n    },\n    inject: function inject(renderer) {\n      var id = Math.random().toString(16).slice(2);\n      hook._renderers[id] = renderer;\n      var reactBuildType = hasDetectedBadDCE ? 'deadcode' : detectReactBuildType(renderer);\n      hook.emit('renderer', { id: id, renderer: renderer, reactBuildType: reactBuildType });\n      return id;\n    },\n    _listeners: {},\n    sub: function sub(evt, fn) {\n      hook.on(evt, fn);\n      return function () {\n        return hook.off(evt, fn);\n      };\n    },\n    on: function on(evt, fn) {\n      if (!hook._listeners[evt]) {\n        hook._listeners[evt] = [];\n      }\n      hook._listeners[evt].push(fn);\n    },\n    off: function off(evt, fn) {\n      if (!hook._listeners[evt]) {\n        return;\n      }\n      var ix = hook._listeners[evt].indexOf(fn);\n      if (ix !== -1) {\n        hook._listeners[evt].splice(ix, 1);\n      }\n      if (!hook._listeners[evt].length) {\n        hook._listeners[evt] = null;\n      }\n    },\n    emit: function emit(evt, data) {\n      if (hook._listeners[evt]) {\n        hook._listeners[evt].map(function (fn) {\n          return fn(data);\n        });\n      }\n    },\n    // Fiber-only:\n    supportsFiber: true,\n    _fiberRoots: {},\n    getFiberRoots: function getFiberRoots(rendererID) {\n      var roots = hook._fiberRoots;\n      if (!roots[rendererID]) {\n        roots[rendererID] = new Set();\n      }\n      return roots[rendererID];\n    },\n\n    onCommitFiberUnmount: function onCommitFiberUnmount(rendererID, fiber) {\n      // TODO: can we use hook for roots too?\n      if (hook.helpers[rendererID]) {\n        hook.helpers[rendererID].handleCommitFiberUnmount(fiber);\n      }\n    },\n    onCommitFiberRoot: function onCommitFiberRoot(rendererID, root) {\n      var mountedRoots = hook.getFiberRoots(rendererID);\n      var current = root.current;\n      var isKnownRoot = mountedRoots.has(root);\n      var isUnmounting = current.memoizedState == null || current.memoizedState.element == null;\n      // Keep track of mounted roots so we can hydrate when DevTools connect.\n      if (!isKnownRoot && !isUnmounting) {\n        mountedRoots.add(root);\n      } else if (isKnownRoot && isUnmounting) {\n        mountedRoots.delete(root);\n      }\n      if (hook.helpers[rendererID]) {\n        hook.helpers[rendererID].handleCommitFiberRoot(root);\n      }\n    }\n  };\n  Object.defineProperty(window, '__REACT_DEVTOOLS_GLOBAL_HOOK__', {\n    value: hook\n  });\n}\n\nmodule.exports = installGlobalHook;\n\n},{}],13:[function(require,module,exports){\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * \n */\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar SEPARATOR = '.';\nvar SUBSEPARATOR = ':';\n\nvar FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n// The Symbol used to tag the ReactElement type. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;\n\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\nfunction escape(key) {\n  var escapeRegex = /[=:]/g;\n  var escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  var escapedString = ('' + key).replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n\n  return '$' + escapedString;\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if ((typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component !== null && component.key != null) {\n    // Explicit key\n    return escape(component.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\n/**\n * We do a copied the 'traverseAllChildrenImpl' method from\n * `React.Children` so that we don't pull in the whole React library.\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {\n  var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  if (children === null || type === 'string' || type === 'number' ||\n  // The following is inlined from ReactElement. This means we can optimize\n  // some checks. React Fiber also inlines this logic for similar purposes.\n  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {\n    callback(traverseContext, children,\n    // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows.\n    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);\n    return 1;\n  }\n\n  var child;\n  var nextName;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getComponentKey(child, i);\n      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n    }\n  } else {\n    var iteratorFn = ITERATOR_SYMBOL && children[ITERATOR_SYMBOL] || children[FAUX_ITERATOR_SYMBOL];\n    if (typeof iteratorFn === 'function') {\n      var iterator = iteratorFn.call(children);\n      var step;\n      var ii = 0;\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getComponentKey(child, ii++);\n        subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);\n      }\n    } else if (type === 'object') {\n      var addendum = ' If you meant to render a collection of children, use an array ' + 'instead.';\n      var childrenString = '' + children;\n      invariant(false, 'The React Devtools cannot render an object as a child. (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);\n    }\n  }\n\n  return subtreeCount;\n}\n\nmodule.exports = traverseAllChildrenImpl;\n\n},{\"fbjs/lib/invariant\":1}],14:[function(require,module,exports){\n'use strict';\n\n/* eslint-disable vars-on-top */\nvar installGlobalHook = require('./react-devtools/backend/installGlobalHook');\nvar Backend = require('./react-devtools/backend/backend');\nvar getData = require('./react-devtools/backend/getData');\nvar getData012 = require('./react-devtools/backend/getData012');\nvar getDataFiber = require('./react-devtools/backend/getDataFiber');\nvar getDisplayName = require('./react-devtools/backend/getDisplayName');\n\ninstallGlobalHook(window);\n\nvar interval = null;\nvar tries = 10;\n\n(function isReactReady() {\n  if (window.__REACT_DEVTOOLS_GLOBAL_HOOK__ && window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers && Object.keys(window.__REACT_DEVTOOLS_GLOBAL_HOOK__._renderers).length > 0) {\n    window.__REACT_DEVTOOLS_GLOBAL_HOOK__.__helpers = {\n      getData: getData, getData012: getData012, getDataFiber: getDataFiber, getDisplayName: getDisplayName\n    };\n    Backend(window.__REACT_DEVTOOLS_GLOBAL_HOOK__);\n  } else {\n    if (tries >= 0) {\n      tries -= 1;\n      clearTimeout(interval);\n      interval = setTimeout(isReactReady, 300);\n    }\n  }\n})();\n\n},{\"./react-devtools/backend/backend\":6,\"./react-devtools/backend/getData\":8,\"./react-devtools/backend/getData012\":9,\"./react-devtools/backend/getDataFiber\":10,\"./react-devtools/backend/getDisplayName\":11,\"./react-devtools/backend/installGlobalHook\":12}]},{},[14])(14)\n});";

// Injecting __REACT_DEVTOOLS_GLOBAL_HOOK__
var script = document.createElement('script');

script.textContent = reactDevToolsConnector.toString();
document.documentElement.appendChild(script);
script.parentNode.removeChild(script);

},{}]},{},[1]);
